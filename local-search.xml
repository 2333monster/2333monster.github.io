<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT6s081 Lec1 Introduction</title>
    <link href="/2023/07/30/MIT6s081%20Lec1%20Introduction/"/>
    <url>/2023/07/30/MIT6s081%20Lec1%20Introduction/</url>
    
    <content type="html"><![CDATA[<blockquote><p>MIT6.s081 操作系统课程的lecture 笔记第一篇: Introduction.</p><p>参考资料</p><p>课程视频中文翻译: <a href="https://github.com/huihongxiao/MIT6.S081/tree/master">https://github.com/huihongxiao/MIT6.S081/tree/master</a></p><p>xv6 中文文档: <a href="https://xv6-chinese.readthedocs.io/zh/latest/index.html">https://xv6-chinese.readthedocs.io/zh/latest/index.html</a></p></blockquote><h1 id="Lec1-Introduction"><a href="#Lec1-Introduction" class="headerlink" title="Lec1: Introduction"></a>Lec1: Introduction</h1><p>这门课程的目标:</p><ol><li>理解操作系统的设计和实现</li><li>通过一个小的XV6的操作系统获得实际动手经验</li></ol><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>操作系统结构即操作系统的内部组成。</p><ul><li><p>底层硬件资源：CPU，内存，磁盘，网卡</p></li><li><p>用户空间程序：shell，文本编辑器，c编译器</p></li><li><p>Kernel</p></li></ul><h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>Kernel程序只有一个，它维护数据来管理每一个用户空间进程。</p><p>Kernel同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用。</p><p>Kernel同时还有大量内置的服务，例如</p><ol><li>文件系统：实现类似文件名，文件内容，目录的东西，并理解如何将文件存储在磁盘中。目前而言，我们可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。</li><li>进程管理系统：每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。同时，Kernel会管理内存的分配。不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。</li><li>Access Control：当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control机制会决定是否允许这样的操作</li><li>其他服务：网络关联的软件（TCP&#x2F;IP协议栈），支持声卡的软件，支持磁盘、网卡的驱动</li></ol><h2 id="系统调用（System-Call）"><a href="#系统调用（System-Call）" class="headerlink" title="系统调用（System Call）"></a>系统调用（System Call）</h2><p>Kernel 与 应用程序的交互 -&gt; Kernel 的 API。它决定了应用程序如何访问Kernel</p><p>这一般通过<strong>系统调用</strong>完成，进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间交替运行。</p><p>内核提供的一系列系统调用就是用户程序可见的操作系统接口，xv6 内核提供了 Unix 传统系统调用的一部分，它们是：</p><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td>fork()</td><td>创建进程</td></tr><tr><td>exit()</td><td>结束当前进程</td></tr><tr><td>wait()</td><td>等待子进程结束</td></tr><tr><td>kill(pid)</td><td>结束 pid 所指进程</td></tr><tr><td>getpid()</td><td>获得当前进程 pid</td></tr><tr><td>sleep(n)</td><td>睡眠 n 秒</td></tr><tr><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr><td>sbrk(n)</td><td>为进程内存空间增加 n 字节</td></tr><tr><td>open(filename, flags)</td><td>打开文件，flags 指定读&#x2F;写模式</td></tr><tr><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr><td>dup(fd)</td><td>复制 fd</td></tr><tr><td>pipe( p)</td><td>创建管道， 并把读和写的 fd 返回到p</td></tr><tr><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr><td>mknod(name, major, minor)</td><td>创建设备文件</td></tr><tr><td>fstat(fd)</td><td>返回文件信息</td></tr><tr><td>link(f1, f2)</td><td>给 f1 创建一个新名字(f2)</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参考.md</title>
    <link href="/2023/07/27/%E5%8F%82%E8%80%83/"/>
    <url>/2023/07/27/%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>hexo+github 部署个人网页 <a href="https://zhuanlan.zhihu.com/p/547520780">https://zhuanlan.zhihu.com/p/547520780</a><br>shell chmod 命令 <a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cs61c-lab01</title>
    <link href="/2023/08/04/cs61c-lab01/"/>
    <url>/2023/08/04/cs61c-lab01/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab1-Number-Rep-C-and-CGDB"><a href="#Lab1-Number-Rep-C-and-CGDB" class="headerlink" title="Lab1: Number Rep, C and CGDB"></a>Lab1: Number Rep, C and CGDB</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) lab 笔记第一篇</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-lab">https://github.com/2333monster/my-cs61c-lab</a></p><p>参考</p><p>gdb调试手册：<a href="https://blog.nowcoder.net/n/1957d46e0ee34168aee2289faf36ee5c#gdb_20">https://blog.nowcoder.net/n/1957d46e0ee34168aee2289faf36ee5c#gdb_20</a></p><p>gdb调试指南：<a href="https://www.yanbinghu.com/2019/04/20/41283.html">https://www.yanbinghu.com/2019/04/20/41283.html</a></p></blockquote><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>获得skeleton code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ git remote add starter https://github.com/61c-teach/fa20-lab-starter.git<br>$ git pull starter master<br></code></pre></td></tr></table></figure><h2 id="Compiling-and-Running-a-C-Program"><a href="#Compiling-and-Running-a-C-Program" class="headerlink" title="Compiling and Running a C Program"></a>Compiling and Running a C Program</h2><p>使用gcc 编译c程序，生成执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ gcc hello.c<br></code></pre></td></tr></table></figure><p>使用执行文件<code>a.out</code>的名称运行c程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ ./a.out<br></code></pre></td></tr></table></figure><p>或者使用<code>-o</code>命令，它能指定执行文件的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ gcc -o hello hello.c<br>$ ./hello<br></code></pre></td></tr></table></figure><h2 id="Exercise-1-See-what-you-can-C"><a href="#Exercise-1-See-what-you-can-C" class="headerlink" title="Exercise 1: See what you can C"></a>Exercise 1: See what you can C</h2><p>本练习中，将看到宏定义处理器的示例</p><p>更改V0 ~ V3 的宏定义，使其输出以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">Berkeley eccentrics:<br>====================<br>Happy Happy Happy<br>Yoshua<br>Go BEARS!<br></code></pre></td></tr></table></figure><p>更改后（好像不要求完全不同，完全不同确实写不出来）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> V0 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V1 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V2 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V3 1</span><br></code></pre></td></tr></table></figure><h2 id="Exercise-2-Catch-those-bugs"><a href="#Exercise-2-Catch-those-bugs" class="headerlink" title="Exercise 2: Catch those bugs!"></a>Exercise 2: Catch those bugs!</h2><p>使用GDB进行Debug，<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/gdb5-refcard.pdf">GDB reference card</a></p><blockquote><p>GDB stands for “GNU De-Bugger.”</p></blockquote><p>使用<code>-g</code>调用 (c)gdb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -g -o hello hello.c</span><br></code></pre></td></tr></table></figure><p>这会生成一个可被<code>gdb</code>识别的可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb hello</span><br></code></pre></td></tr></table></figure><p><strong>gdb常用调试指令</strong></p><table><thead><tr><th>调试指令</th><th>作用</th></tr></thead><tbody><tr><td>b（break） 行号</td><td>在源代码指定的某一行设置断点，其中行号用于指定具体打断点的位置。</td></tr><tr><td>r（run）</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行。</td></tr><tr><td>n（next）(int)</td><td>令程序一行代码一行代码的执行。执行n次</td></tr><tr><td>p（print） 变量名</td><td>打印指定变量的值</td></tr><tr><td>l（list）</td><td>显示源程序代码的内容，包括各行代码所在的行号。</td></tr><tr><td>q（quit）</td><td>终止调试。</td></tr></tbody></table><p>断点设置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break location    //b 位置<br>(gdb) break ... if cond //b 表达式<br></code></pre></td></tr></table></figure><ul><li>location</li></ul><table><thead><tr><th>location 的值</th><th>含 义</th></tr></thead><tbody><tr><td>linenum</td><td>linenum 是一个整数，表示要打断点处代码的行号。</td></tr><tr><td>filename:linenum</td><td>filename 表示源程序文件名；linenum 为整数，表示具体行数。整体的意思是在指令文件 filename 中的第 linenum 行打断点。</td></tr><tr><td>+ offset</td><td>offset 为整数，+offset 表示以当前程序暂停位置为准，<strong>向后数</strong> offset 行处打断点</td></tr><tr><td>- offset</td><td>offset 为整数，-offset 表示以当前程序暂停位置为准，<strong>向前数</strong> offset 行处打断点</td></tr><tr><td>function</td><td>function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。</td></tr><tr><td>filename:function</td><td>filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。</td></tr></tbody></table><ul><li>cond<ul><li>表达式</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b 7 if num&gt;10  //如果num&gt;10 在第 7 行打断点<br></code></pre></td></tr></table></figure><h3 id="Action-Item"><a href="#Action-Item" class="headerlink" title="Action Item"></a>Action Item</h3><ol><li>setting a breakpoint at main</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b hello.c: main<br></code></pre></td></tr></table></figure><ol start="2"><li>using gdb’s run command</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run<br></code></pre></td></tr></table></figure><ol start="3"><li>using gdb’s single-step command</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n<br></code></pre></td></tr></table></figure><h4 id="gdb-questions"><a href="#gdb-questions" class="headerlink" title="gdb questions"></a>gdb questions</h4><ol><li><p>While you’re in a gdb session, how do you <strong>set the arguments</strong> that will be passed to the program when it’s run?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set args 5<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>create a breakpoint</strong>?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">b filename: linenum<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>execute the next line of C code</strong> in the program after stopping at a breakpoint?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n(next) / s(step)<br></code></pre></td></tr></table></figure></li><li><p>If the next line of code is a function call, you’ll execute the whole function call at once if you use your answer to #3. (If not, consider a different command for #3!) How do you tell GDB that you <strong>want to debug the code inside the function</strong> (i.e. step into the function) instead? (If you changed your answer to #3, then that answer is most likely now applicable here.)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">step<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>continue the program after stopping</strong> at a breakpoint?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run<br></code></pre></td></tr></table></figure></li><li><p>How can you <strong>print the value of a variable</strong> (or even an expression like 1+2) in gdb?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">p 1+2<br>p variable_name<br></code></pre></td></tr></table></figure></li><li><p>How do you configure gdb so it <strong>displays the value of a variable after every step</strong>?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">display variable<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>show a list of all variables and their values</strong> in the current function?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">info args<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>quit</strong> out of gdb?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">q<br></code></pre></td></tr></table></figure></li></ol><h2 id="Exercise-3-Debugging-w-YOU-ser-input"><a href="#Exercise-3-Debugging-w-YOU-ser-input" class="headerlink" title="Exercise 3: Debugging w&#x2F; YOU(ser input)"></a>Exercise 3: Debugging w&#x2F; YOU(ser input)</h2><p>好像是关于redirection ，没懂</p><h2 id="Exercise-4-Valgrind’ing-away"><a href="#Exercise-4-Valgrind’ing-away" class="headerlink" title="Exercise 4: Valgrind’ing away"></a>Exercise 4: Valgrind’ing away</h2><p>有两种bug类型</p><ol><li>bohrbugs：在一致的稳定的情况下会重复出现的错误</li><li>heisenbugs：在相同情况下不一定会重复出现，一般由于内存管理不当</li></ol><p>使用Valgrind 找出”heisenbugs” </p><blockquote><p>To help catch these “heisenbugs” we will use a tool called Valgrind. Valgrind is a program which emulates your CPU and tracks your memory accesses. This slows down the process you’re running (which is why we don’t, for example, always run all executables inside Valgrind) but also can expose bugs that may only display visible incorrect behavior under a unique set of circumstances.</p></blockquote><p>安装valgrind （在ubuntu环境下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install valgrind</span><br></code></pre></td></tr></table></figure><p><code>segfault_ex</code> 出现错误的原因</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;<br>        a[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问数组外未定义的内存，典型的heisenbug。</p><p><strong>使用valgrind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o segfault_ex.exe segfault_ex.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">valgrind ./segfault_ex.exe</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">==15931== Invalid write of size 4<br>==15931==   at 0x10914F: main (in /home/moxilai/cs61c-lab/lab01/segfault.exe)<br>==15931== Address 0x1fff001000 is not stack&#x27;d, malloc&#x27;d or (recently) free&#x27;d<br></code></pre></td></tr></table></figure><p><code>no_segfalut</code> 的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">unsigned</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(a); j++) &#123;<br>        total += a[j];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum of array is %d\n&quot;</span>, total);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for (int j = 0; j &lt; sizeof(a); j++)</code> 使用sizeof(a) a 是一个包含五个元素的整型数组，sizeof的结果是5*4&#x3D;20，而不是5，导致访问未定义的内存，从而产生未知的结果。这是一个典型的Heisenbug问题，因为其结果取决于内存中未定义的值，可能会导致程序崩溃或输出错误的结果。</p><p><strong>使用valgrind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o no_segfault.exe no_segfault_ex.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">valgrind ./no_segfault.exe</span><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D9B56: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Use of uninitialised value of size 8<br>==16089==    at 0x48BD33B: _itoa_word (_itoa.c:177)<br>==16089==    by 0x48D8B3D: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48BD34C: _itoa_word (_itoa.c:177)<br>==16089==    by 0x48D8B3D: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D9643: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D8C85: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br></code></pre></td></tr></table></figure><p>关键词：uninitialised value </p><p>分析上面两个程序</p><ol><li><p>Why <strong>didn’t</strong> the <code>no_segfault_ex</code> program segfault?<br>首先c以这种形式分配数组内存是stack中给了一个指针，随着j的增大，会访问a[5]~a[19]这实际是a+5 ~ a+19 的内存，这些内存是存在的，由于这不是分配给a 的内存，且没有初始化，其中会存储着脏数据，导致不可确定的。不过由于没有超出stack的容量，不会造成segfault（程序崩溃）</p></li><li><p>Why does the <code>no_segfault_ex</code> produce inconsistent outputs?<br>同上，不确定的数据导致不确定的输出</p></li><li><p>Why is <code>sizeof</code> incorrect? How could you still use <code>sizeof</code> but make the code correct?<br>同上，更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>arraylength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arraylength;j++)<br>    ...<br></code></pre></td></tr></table></figure></li></ol><h2 id="Exercise-5-Pointers-and-Structures-in-C"><a href="#Exercise-5-Pointers-and-Structures-in-C" class="headerlink" title="Exercise 5: Pointers and Structures in C"></a>Exercise 5: Pointers and Structures in C</h2><p>在ll_cycle.c中，完成函数ll_has_cycle()来实现以下检查单向链表是否有环的算法。</p><ol><li>Start with two pointers at the head of the list. We’ll call the first one tortoise and the second one hare.</li><li>Advance hare by two nodes. If this is not possible because of a null pointer, we have found the end of the list, and therefore the list is acyclic.</li><li>Advance tortoise by one node.</li><li>If tortoise and hare point to the same node, the list is cyclic. Otherwise, go back to step 2.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6s081-lab1-Unix utilities</title>
    <link href="/2023/07/31/MIT6s081-lab1-Unix%20utilities/"/>
    <url>/2023/07/31/MIT6s081-lab1-Unix%20utilities/</url>
    
    <content type="html"><![CDATA[<blockquote><p>MIT6.s081 的lab1 笔记<br>课程主页：<a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a><br>视频翻译：<a href="https://github.com/huihongxiao/MIT6.S081">https://github.com/huihongxiao/MIT6.S081</a><br>xv6中文文档：<a href="https://xv6-chinese.readthedocs.io/zh/latest/docs">https://xv6-chinese.readthedocs.io/zh/latest/docs</a><br>我的代码地址：<a href="https://github.com/2333monster/my-xv6-labs-2021">https://github.com/2333monster/my-xv6-labs-2021</a></p></blockquote><h1 id="Lab-1-Unix-utilities"><a href="#Lab-1-Unix-utilities" class="headerlink" title="Lab 1 Unix utilities"></a>Lab 1 Unix utilities</h1><p>熟悉xv6系统和system calls</p><h2 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h2><p>设置linux 环境，克隆仓库，QEMU</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ git clone git://g.csail.mit.edu/xv6-labs-2021<br>$ cd xv6-labs-2021<br>$ git checkout util<br>$ make qemu<br></code></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.s081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参考.md</title>
    <link href="/2023/07/27/%E5%8F%82%E8%80%83/"/>
    <url>/2023/07/27/%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>hexo+github 部署个人网页 <a href="https://zhuanlan.zhihu.com/p/547520780">https://zhuanlan.zhihu.com/p/547520780</a><br>shell chmod 命令 <a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

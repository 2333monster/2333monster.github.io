<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cs61c-lab02</title>
    <link href="/2023/08/10/cs61c-lab02/"/>
    <url>/2023/08/10/cs61c-lab02/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab-2-Advanced-C"><a href="#Lab-2-Advanced-C" class="headerlink" title="Lab 2: Advanced C"></a>Lab 2: Advanced C</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) lab 笔记第二篇</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-lab">https://github.com/2333monster/my-cs61c-lab</a></p></blockquote><h2 id="Exercise-0-Makefiles"><a href="#Exercise-0-Makefiles" class="headerlink" title="Exercise 0: Makefiles"></a>Exercise 0: Makefiles</h2><p>makefile教程：<a href="https://seisman.github.io/how-to-write-makefile/introduction.html">https://seisman.github.io/how-to-write-makefile/introduction.html</a></p><img src="/2023/08/10/cs61c-lab02/makefile.png" class=""><h2 id="Exercise-1-Bit-Operations"><a href="#Exercise-1-Bit-Operations" class="headerlink" title="Exercise 1: Bit Operations"></a>Exercise 1: Bit Operations</h2><p>完成<code>get_bit</code>, <code>set_bit</code>, and <code>flip_bit</code></p><p>独立完成后，查看别人的实现学习到了更简洁更直观的表达，就理下别人的思路</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> x,</span><br><span class="hljs-params">                 <span class="hljs-type">unsigned</span> n)</span> &#123;<br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    <span class="hljs-comment">// Returning -1 is a placeholder (it makes</span><br>    <span class="hljs-comment">// no sense, because get_bit only returns</span><br>    <span class="hljs-comment">// 0 or 1)</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&amp;(x&gt;&gt;n));<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>(x &gt;&gt; n)</code>：首先，将整数 <code>x</code> 向右移动 <code>n</code> 位，以便将第 <code>n</code> 位移到最低位，这样我们可以轻松地从最低位提取出这个位的值。</li><li><code>(1 &amp; (x &gt;&gt; n))</code>：然后，将移位后的结果与二进制数 <code>0b00000001</code>（即1）进行按位与操作。这将保留右移后的结果的最低位，也就是第 <code>n</code> 位。</li><li><code>return (1 &amp; (x &gt;&gt; n));</code>：最后，将上述按位与操作的结果作为函数的返回值，即返回第 <code>n</code> 位的值（0 或 1）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">set_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> * x,</span><br><span class="hljs-params">             <span class="hljs-type">unsigned</span> n,</span><br><span class="hljs-params">             <span class="hljs-type">unsigned</span> v)</span> &#123;<br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    <span class="hljs-type">unsigned</span> mask = ~(<span class="hljs-number">1</span>&lt;&lt;n);<br>    (*x) = ((*x) &amp; mask)|(v &lt;&lt; n);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>unsigned mask = ~(1&lt;&lt;n);</code>：首先，创建一个掩码 <code>mask</code>，它的目的是将第 <code>n</code> 位设置为0，其他位都保持不变。这是通过将数字1左移 <code>n</code> 位然后取反得到的，实际上就是将第 <code>n</code> 位设置为0，其他位都设置为1。</li><li><code>(*x) = ((*x) &amp; mask)|(v &lt;&lt; n);</code>：然后，使用掩码和左移操作将指定的位设置为新的值 <code>v</code>。<ul><li><code>(*x) &amp; mask</code>：这个步骤将保留 <code>x</code> 中除第 <code>n</code> 位以外的所有位，通过将 <code>x</code> 和掩码 <code>mask</code> 进行按位与操作。</li><li><code>v &lt;&lt; n</code>：将值 <code>v</code> 左移 <code>n</code> 位，将要设置的位放置在正确的位置。</li><li><code>((*x) &amp; mask) | (v &lt;&lt; n)</code>：将上述两个步骤的结果进行按位或操作，将保留的部分与设置的位合并，得到最终的结果。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">flip_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> * x,</span><br><span class="hljs-params">              <span class="hljs-type">unsigned</span> n)</span> &#123;<br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    (*x)^=(<span class="hljs-number">1</span>&lt;&lt;n);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>(1 &lt;&lt; n)</code>：首先，将数字1左移 <code>n</code> 位，生成一个只有第 <code>n</code> 位为1，其他位为0的数。例如，如果 <code>n</code> 是3，则 <code>1 &lt;&lt; 3</code> 的结果是二进制数 <code>0b00001000</code>。</li><li><code>(*x) ^= (1 &lt;&lt; n);</code>：然后，将左移后的结果与原始值 <code>x</code> 进行按位异或操作（<code>^=</code> 表示按位异或赋值操作）。按位异或操作的性质是，对于两个操作数的每一位，如果两个操作数的对应位不同，则结果的该位为1，否则为0。因此，这个操作将会翻转 <code>x</code> 的第 <code>n</code> 位。</li></ol><h2 id="Exercise-2-Linear-Feedback-Shift-Register"><a href="#Exercise-2-Linear-Feedback-Shift-Register" class="headerlink" title="Exercise 2: Linear Feedback Shift Register"></a>Exercise 2: Linear Feedback Shift Register</h2><p>很简单的一个东西，由于makefile 设置的原因，不要调用<code>bit_ops.c</code>的函数在<code>lfsr.c</code>中</p><p><a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">lfsr</a>倒是蛮有意思</p><h2 id="Exercise-3-Memory-Management"><a href="#Exercise-3-Memory-Management" class="headerlink" title="Exercise 3: Memory Management"></a>Exercise 3: Memory Management</h2><p>最开始没想明白两个函数为什么有问题，只是觉得跟之前写的不一样，因为之前结构也要malloc分配空间。</p><p>贴上chatgpt的解释</p><h3 id="bad-vector-new"><a href="#bad-vector-new" class="headerlink" title="bad_vector_new()"></a><em>bad_vector_new()</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Bad example of how to create a new vector */</span><br><span class="hljs-type">vector_t</span> *<span class="hljs-title function_">bad_vector_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* Create the vector and a pointer to it */</span><br>    <span class="hljs-type">vector_t</span> *retval, v;<br>    retval = &amp;v;<br><br>    <span class="hljs-comment">/* Initialize attributes */</span><br>    retval-&gt;size = <span class="hljs-number">1</span>;<br>    retval-&gt;data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (retval-&gt;data == <span class="hljs-literal">NULL</span>) &#123;<br>        allocation_failed();<br>    &#125;<br><br>    retval-&gt;data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>它试图返回一个指向局部变量的指针，这会导致悬空指针问题，而且在修改局部变量的成员时也会导致未定义行为。</p><p>具体来说，这段代码的问题在于：</p><ol><li><code>vector_t v;</code>：在<strong>堆栈</strong>上创建了一个局部变量 <code>v</code>，它的生命周期仅限于 <code>bad_vector_new()</code> 函数的执行期间。</li><li><code>retval = &amp;v;</code>：将局部变量 <code>v</code> 的地址赋给了 <code>retval</code>，使得 <code>retval</code> 指向了局部变量 <code>v</code> 所在的内存地址。</li><li><code>retval-&gt;size = 1;</code> 和 <code>retval-&gt;data = malloc(sizeof(int));</code>：试图在局部变量 <code>v</code> 上操作，但由于它是在堆栈上分配的，这会导致未定义行为。这意味着你正在修改一个局部变量的成员，而不是动态分配的内存。</li><li><code>return retval;</code>：返回了指向局部变量 <code>v</code> 的指针 <code>retval</code>。</li></ol><p>这会导致类似前面提到的问题，当函数 <code>bad_vector_new()</code> 结束时，局部变量 <code>v</code> 将被销毁，但是 <code>retval</code> 仍然指向了该内存地址，从而导致悬空指针。同时，试图在局部变量上进行成员访问也会导致未定义行为。</p><h3 id="also-bad-vector-new"><a href="#also-bad-vector-new" class="headerlink" title="also_bad_vector_new()"></a><em>also_bad_vector_new()</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Another suboptimal way of creating a vector */</span><br><span class="hljs-type">vector_t</span> <span class="hljs-title function_">also_bad_vector_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* Create the vector */</span><br>    <span class="hljs-type">vector_t</span> v;<br><br>    <span class="hljs-comment">/* Initialize attributes */</span><br>    v.size = <span class="hljs-number">1</span>;<br>    v.data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (v.data == <span class="hljs-literal">NULL</span>) &#123;<br>        allocation_failed();<br>    &#125;<br>    v.data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>它试图返回一个局部变量 <code>v</code>，它在函数结束时将会被销毁，导致悬空指针问题。</p><p>具体问题如下：</p><ol><li><code>vector_t v;</code>：在堆栈上创建了一个局部变量 <code>v</code>，它的生命周期仅限于 <code>also_bad_vector_new()</code> 函数的执行期间。</li><li><code>v.size = 1;</code> 和 <code>v.data = malloc(sizeof(int));</code>：在局部变量 <code>v</code> 上操作，分配了内存并将指针存储在 <code>v.data</code> 中。由于 <code>v</code> 是在堆栈上分配的，当函数 <code>also_bad_vector_new()</code> 结束时，局部变量 <code>v</code> 将被销毁，导致 <code>v.data</code> 指向的内存变成了悬空指针。</li><li><code>return v;</code>：试图返回局部变量 <code>v</code>。</li></ol><p>这会导致悬空指针问题，因为在函数结束后，局部变量 <code>v</code> 将被销毁，但是返回的 <code>v</code> 中的指针 <code>v.data</code> 仍然指向了之前分配的内存地址</p><div class="note note-info">            <p>综上，就是malloc这个应该在heap上调用的函数，不应用到stack上，导致的一系列问题</p>          </div><h3 id="vector-new"><a href="#vector-new" class="headerlink" title="vector_new()"></a><em>vector_new()</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">vector_t</span> *<span class="hljs-title function_">vector_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* Declare what this function will return */</span><br>    <span class="hljs-type">vector_t</span> *retval;<br><br>    <span class="hljs-comment">/* First, we need to allocate memory on the heap for the struct */</span><br>    retval = (<span class="hljs-type">vector_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">vector_t</span>));<br>  <br><br>    <span class="hljs-comment">/* Check our return value to make sure we got memory */</span><br>    <span class="hljs-keyword">if</span> (retval == <span class="hljs-literal">NULL</span>) &#123;<br>        allocation_failed();<br>    &#125;<br><br>    <span class="hljs-comment">/* Now we need to initialize our data.</span><br><span class="hljs-comment">       Since retval-&gt;data should be able to dynamically grow,</span><br><span class="hljs-comment">       what do you need to do? */</span><br>    retval-&gt;size = <span class="hljs-number">1</span><span class="hljs-comment">/* YOUR CODE HERE */</span>;<br>    retval-&gt;data = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">/* YOUR CODE HERE */</span>;<br><br>    <span class="hljs-comment">/* Check the data attribute of our vector to make sure we got memory */</span><br>    <span class="hljs-keyword">if</span> (retval-&gt;data == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">free</span>(retval);<span class="hljs-comment">//Why is this line necessary?</span><br>        allocation_failed();<br>    &#125;<br><br>    <span class="hljs-comment">/* Complete the initialization by setting the single component to zero */</span><br>    <span class="hljs-comment">/* YOUR CODE HERE */</span> <br>    retval-&gt;data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* and return... */</span><br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>正常思路，给struct 手动分配内存就好</p><h3 id="vector-set"><a href="#vector-set" class="headerlink" title="vector_set()"></a><em>vector_set()</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vector_set</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-comment">/* What do you need to do if the location is greater than the size we have</span><br><span class="hljs-comment">     * allocated?  Remember that unset locations should contain a value of 0.</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* YOUR SOLUTION HERE */</span><br>    <span class="hljs-keyword">if</span>(loc &gt;= v-&gt;size)&#123;<br>        <span class="hljs-type">size_t</span> new_size = loc + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>* new_data = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">realloc</span>(v-&gt;data,new_size*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span>(new_data == <span class="hljs-literal">NULL</span>)&#123;<br>            allocation_failed();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = v-&gt;size ; i &lt; new_size; i++)&#123;<br><br>            v-&gt;data[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        v-&gt;size = new_size;<br>        v-&gt;data = new_data;<br>    &#125;<br>    v-&gt;data[loc] = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意设0时，别覆盖了之前设置过值就好</p><h3 id="makefile-test"><a href="#makefile-test" class="headerlink" title="makefile test"></a>makefile test</h3><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">Calling vector_new()<br>Calling vector_delete()<br>vector_new() again<br>These should all return 0 (vector_get()): 0 0 0<br>Doing a bunch of vector_set()s<br>These should be equal:<br>98 = 98<br>15 = 15<br>65 = 65<br>-123 = -123<br>21 = 21<br>43 = 43<br>0 = 0<br>0 = 0<br>0 = 0<br>3 = 3<br>Test complete.<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><em>在 makefile 中为</em> <code>vector-test</code> <em>目标实施规则。</em><img src="/2023/08/10/cs61c-lab02/vector_set1.png" class=""></li><li><em>在 vector.h 中添加函数声明</em><img src="/2023/08/10/cs61c-lab02/vector_set2.png" class=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-lec</title>
    <link href="/2023/08/09/cs61c-lec/"/>
    <url>/2023/08/09/cs61c-lec/</url>
    
    <content type="html"><![CDATA[<h1 id="Lec06-Floating-Point"><a href="#Lec06-Floating-Point" class="headerlink" title="Lec06 Floating Point"></a>Lec06 Floating Point</h1><ul><li><p>规格化</p><img src="/2023/08/09/cs61c-lec/Normalformat.jpg" class="" title="examplename"></li><li><p>overflow - underflow</p><img src="/2023/08/09/cs61c-lec/Overflow.png" class="" title="examplename"></li><li><p>浮点数standard - sign exponent significand </p></li><li><p>IEEE 754 使用 “biased exponent” 表示 + 原因（P&amp;H p136)</p><img src="/2023/08/09/cs61c-lec/biasednotation.png" class="" title="examplename"></li><li><p>浮点数实际表示值（使用biased notation后）（-1)^S x (1+Significand) x 2^(Exponent-127)</p></li><li><p>FP 表示0；<code>infinity</code>；<code>NaN</code>(Not a Number) (<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/pdfs/lectures/lec06.pdf">sild lec06</a> p19-p23)</p></li><li><p>FP 表示<code>Denorms</code>(非规格化数) 重要理解  <a href="https://youtu.be/Gs0ARZzY-gM?list=PLnvUoC1Ghb7zz9gZ7A6DHo_YI7m_QtTwo&t=456">https://youtu.be/Gs0ARZzY-gM?list=PLnvUoC1Ghb7zz9gZ7A6DHo_YI7m_QtTwo&amp;t=456</a></p><img src="/2023/08/09/cs61c-lec/Denorms.png" class="" title="examplename"></li><li><p>表示 1&#x2F;3</p></li><li><p>FP 加法不可交换</p></li><li><p>FP Precision &amp; Accuracy</p></li><li><p>舍入操作 （P &amp; H 3.5.7)</p><img src="/2023/08/09/cs61c-lec/round.png" class="" title="examplename"></li><li><p>由于浮点数的significand 每次加一后，对整个浮点数其实加1*2^(exponent+127)，所以它会跳过某些数</p><ul><li>因此，无法精确表示且将舍入的第一个整数是：<br>对于<code>float</code>而言，16,777,217（224 + 1）。<br>对于<code>double</code>而言，9,007,199,254,740,993（253 + 1 ）。<img src="/2023/08/09/cs61c-lec/simulator.png" class="" title="examplename"></li></ul></li><li><p><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE 754 simulator</a></p></li></ul><h1 id="Lec07-RISC-V-Intro"><a href="#Lec07-RISC-V-Intro" class="headerlink" title="Lec07 RISC-V Intro"></a>Lec07 RISC-V Intro</h1><ul><li><p>Risc-V 抽象层</p><img src="/2023/08/09/cs61c-lec/abstraction.png" class="" title="examplename"></li><li><p>Risc-v -&gt; ISA(<em>Instrument Set Architecture</em>)</p><img src="/2023/08/09/cs61c-lec/assembly.png" class="FP" title="examplename"></li><li><p>寄存器(register)</p></li><li><p>基础操作符 - add sub addi</p></li></ul><h1 id="Lec08-RISC-V-lw-sw-Decisions-I"><a href="#Lec08-RISC-V-lw-sw-Decisions-I" class="headerlink" title="Lec08 RISC-V lw, sw, Decisions I"></a>Lec08 RISC-V lw, sw, Decisions I</h1><ul><li>字节<br>1个字32个位，即4个字节；一个字节8个位。<img src="/2023/08/09/cs61c-lec/Address.png" class="" title="examplename"></li><li>小尾数法(Little Endian) 内存存储字节<img src="/2023/08/09/cs61c-lec/littleendian.png" class="" title="examplename"></li><li>从寄存器访问比从内存访问快<img src="/2023/08/09/cs61c-lec/register-memory.png" class="" title="examplename"></li><li><code>lw</code> Load from Memory to Register (一个字32位)<img src="/2023/08/09/cs61c-lec/lw.png" class="" title="examplename"></li><li><code>sw</code> Store from Register to Memory (一个字32位)<img src="/2023/08/09/cs61c-lec/sw.png" class="" title="examplename"></li><li>加载存储字节, 加载8位而不是32位，存储到寄存器中时需要<code>sign-extend</code> <img src="/2023/08/09/cs61c-lec/lwbytes.png" class="" title="examplename"><img src="/2023/08/09/cs61c-lec/example01.png" class="" title="examplename"></li><li>保留addi 的原因<img src="/2023/08/09/cs61c-lec/save_addi.png" class="" title="examplename"></li><li>beq; bne; blt; bge</li><li>j(jump) label</li><li>if-else 语法<img src="/2023/08/09/cs61c-lec/if-example.png" class="" title="examplename"></li><li>for-loop 语法<img src="/2023/08/09/cs61c-lec/for-loop.png" class="" title="examplename"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-proj1</title>
    <link href="/2023/08/05/cs61c-proj1/"/>
    <url>/2023/08/05/cs61c-proj1/</url>
    
    <content type="html"><![CDATA[<h1 id="Project-1-Conway’s-Game-of-Life-in-RGB"><a href="#Project-1-Conway’s-Game-of-Life-in-RGB" class="headerlink" title="Project 1: Conway’s Game of Life, in RGB!"></a>Project 1: Conway’s Game of Life, in RGB!</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) proj1 笔记</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-proj">https://github.com/2333monster/my-cs61c-proj</a></p></blockquote><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><img src="https://inst.eecs.berkeley.edu/~cs61c/fa20/projects/proj1/conway.gif" alt="img" style="zoom: 25%;" /><p>实现Game of LIfe.</p><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>原仓库设置为只读，我下载了源码解压</p><h3 id="PPM-Format"><a href="#PPM-Format" class="headerlink" title="PPM Format"></a>PPM Format</h3><p>PPM是一种存储图片的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PLaintext">P3<br>4 5<br>255<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>255 255 255   255 255 255   255 255 255     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br><br></code></pre></td></tr></table></figure><p>头部第一行 P3 -&gt; 这是一个P3格式的PPM 文件（还有5种格式）</p><p>头部第二行 4 5 -&gt; 图片 4 pixels 宽 5 pixels 高 </p><p>头部第三行 255 -&gt; 描述颜色值的范围 0~255</p><p>文件的余下部分是图片的实际像素，每个像素有三个数字描述分别代表红，绿，蓝</p><p>使用<code>convert</code> 命令转换.ppm格式到其他标准格式。</p><blockquote><p>The command <code>convert -compress none glider.png glider.ppm </code>can convert a png to a PPM P3 format, albeit with a different spacing convention than the one we will be using in this project. Similarly, the command <code>convert glider.ppm glider.png </code>can be used to convert a ppm back to a png. This can be useful for debugging purposes, and seeing the actual image files</p></blockquote><h3 id="File-I-O"><a href="#File-I-O" class="headerlink" title="File I&#x2F;O"></a>File I&#x2F;O</h3><p>以<code>Color</code>存储pixel 的颜色，<code>Image</code>形式存储所有图片</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Color</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint8_t</span> R;<br><span class="hljs-type">uint8_t</span> G;<br><span class="hljs-type">uint8_t</span> B;<br>&#125; Color;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Image</span></span><br><span class="hljs-class">&#123;</span><br>Color **image;<br><span class="hljs-type">uint32_t</span> rows;<br><span class="hljs-type">uint32_t</span> cols;<br>&#125; Image;<br></code></pre></td></tr></table></figure><p>使用file I&#x2F;O 管理文件 <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen</a> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose</a>  <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fscanf.htm">fscanf</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fopen opens a file pointer to the &quot;diary.txt&quot; file.</span><br><span class="hljs-comment">// The &quot;r&quot; indicates that the file should be opened in &quot;read mode&quot;.</span><br><span class="hljs-comment">// Other modes are detailed in the documentation linked above.</span><br>FILE *fp = fopen(<span class="hljs-string">&quot;diary.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-comment">// fscanf reads the first word and first number from the given file pointer into buf and num, respectively.</span><br><span class="hljs-comment">// The second argument is a string format, specifying what exactly fscanf should be reading from the file pointer.</span><br><span class="hljs-comment">// More options can for the string format can be found in the documentation linked above,</span><br><span class="hljs-comment">// but you may need to Google to figure out how to scan in specific types.</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> num;<br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%s %d&quot;</span>, buf, &amp;num);<br><br><span class="hljs-comment">// fclose simply closes the file pointer after we&#x27;re done with it.</span><br><span class="hljs-comment">// This frees the memory that fopen allocated for the file.</span><br><span class="hljs-comment">// This is also a necessary step whenever we are writing to a file:</span><br><span class="hljs-comment">// without closing the pointer, you may lose the last few lines</span><br><span class="hljs-comment">// you want to write.</span><br>fclose(fp);<br></code></pre></td></tr></table></figure><h2 id="Part-A1"><a href="#Part-A1" class="headerlink" title="Part A1"></a>Part A1</h2><p>实现见 <a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/imageloader.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/imageloader.c</a></p><h3 id="readData"><a href="#readData" class="headerlink" title="readData()"></a><strong>readData()</strong></h3><p>主要关注下分配空间，理清楚malloc()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Image *img = (Image*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Image));<br></code></pre></td></tr></table></figure><p>这里分配了一个 <code>Image</code>结构体的空间，用于存储图像的信息，包括图像的行数，列数，以及指向像素空间的指针<br>分配<code>sizeof(struct Image)</code>大小的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">img-&gt;image = (Color **)<span class="hljs-built_in">malloc</span>(totpixel*<span class="hljs-keyword">sizeof</span>(Color*));<br></code></pre></td></tr></table></figure><p>这里分配了一个指针数组，用于存储<code>Color</code>结构体的指针。</p><blockquote><p><code>img-&gt;image</code>为<code>Color **</code> 即 <code>img</code>是一个指向指针数组的指针，其中的每个指针指向一个<code>Color</code>对象</p></blockquote><p><code>Img</code>是一个<code>Color**</code> 类型，指向的对象是包含 <code>totpixel</code> 个 Color* 的指针数组<br>分配<code>totpixel*sizeof(Color *)</code> 大小的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;totpixel;i++)&#123;<br>    *(img-&gt;image+i) = (Color*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Color));`<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在上一步分配的指针数组中的每一个指针指向的位置，分配了一个<code>Color</code> 结构体的内存</p><p><code>*(img-&gt;image + i)</code> 是一个 <code>Color*</code> 类型，所以我们分配了 <code>sizeof(Color)</code> 字节的内存空间，来存储每个像素的颜色数据。</p><p>其次<code>fscanf</code>的参数我是根据<code>make imageloader</code>的报错结果修改的，我最开始是认为是<code>3u</code>的就是3位数的unit32，不理解<code>hhu</code>是什么原因。</p><div class="note note-info">            <p>注：hhu时unit8的读取</p>          </div><h3 id="WriteData-Free"><a href="#WriteData-Free" class="headerlink" title="WriteData() &amp; Free()"></a>WriteData() &amp; Free()</h3><p>逻辑上很简单，Free()的话，记得倒着释放，不然会找不到之后的地址。</p><h2 id="Part-A2"><a href="#Part-A2" class="headerlink" title="Part A2"></a>Part A2</h2><p>完成<code>Steganography</code>，完整见<a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/steganography.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/steganography.c</a></p><p>基于<a href="https://zh.wikipedia.org/wiki/%E9%9A%90%E5%86%99%E6%9C%AF">隐写术</a></p><blockquote><p>载体文件（cover file）相对隐秘文件的大小（指数据含量，以比特计）越大，隐藏后者就越加容易。</p><p>因为这个原因，数字图像（包含有大量的数据）在互联网和其他传媒上被广泛用于隐藏消息。这种方法使用的广泛程度无从查考。例如：一个24位的位图中的每个像素的三个颜色分量（红，绿和蓝）各使用8个比特来表示。如果我们只考虑蓝色的话，就是说有28种不同的数值来表示深浅不同的蓝色。而像11111111和11111110这两个值所表示的蓝色，人眼几乎无法区分。因此，这个最低有效位就可以用来存储颜色之外的信息，而且在某种程度上几乎是检测不到的。如果对红色和绿色进行同样的操作，就可以在差不多三个像素中存储一个字节的信息。</p><p>更正式一点地说，使隐写的信息难以探测的，也就是保证“有效载荷”（需要被隐蔽的信号）对“载体”（即原始的信号）的调制对载体的影响看起来（理想状况下甚至在统计上）可以忽略。这就是说，这种改变应该无法与载体中的噪声加以区别。</p><p>隐写术也可以用作电子水印，这里一条消息（往往只是一个标识符）被隐藏到一幅图像中，使得其来源能够被跟踪或校验。但往往隐写术不具有良好的强健性，当图像被稍微修改后，隐入的消息就无法提取校验了。</p></blockquote><h3 id="evaluateOnePixel"><a href="#evaluateOnePixel" class="headerlink" title="evaluateOnePixel"></a>evaluateOnePixel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据给定的图片和行列确定该位置像素的颜色，要求不影响原图片，给新的颜色分配空间</span><br>Color *<span class="hljs-title function_">evaluateOnePixel</span><span class="hljs-params">(Image *image, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span><br></code></pre></td></tr></table></figure><p>返回值是一个<code>Color *</code>，设置为<code>secret</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Color * secret = (Color *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Color));<br></code></pre></td></tr></table></figure><p>根据原理，确定该位置的颜色</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> LSB = (*p)-&gt;B &amp; <span class="hljs-number">1</span>;<br>secret-&gt;B = secret-&gt;G = secret-&gt;R = LSB*<span class="hljs-number">255</span>;<br></code></pre></td></tr></table></figure><h3 id="steganography"><a href="#steganography" class="headerlink" title="steganography"></a>steganography</h3><p>对每个像素分别调用<code>evaluateOnePixel</code>即可</p><div class="note note-info">            <p>完成part A2 时最好自己写测试，而不是使用make steganography命令，至少在我这里，这个命令会导致之前编译成功的<code>makeloader.c</code>的<code>fscanf</code>的参数出现问题。</p><p>另编译时，应该同时编译<code>steganography.c</code>和<code>makeloader.c</code>，因为<code>#include &quot;makeloader.h&quot;</code> 即</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o steganography steganography.c makeloader.c<br></code></pre></td></tr></table></figure>          </div><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>完成 <strong>The Game of Life</strong> 完整代码见<a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/gameoflife.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/gameoflife.c</a></p><blockquote><p>规则：</p><ol><li>任何一个周围（8个邻居中）有2或3个活细胞的活细胞，在下一代存活</li><li>任何一个周围有3个或者细胞邻居的死细胞，在下一代存活</li><li>所有其他类型的活细胞下一代带死亡，死细胞下一代仍死亡</li></ol></blockquote><p>规则编码</p><table>  <tbody>    <tr>      <th>If my state is...</th>      <th colspan="9"> alive (1)</th>      <th colspan="9"> dead (0)</th>    </tr>    <tr>      <th>And the number of alive neighbors is...</th>      <td>8</td>      <td>7</td>      <td>6</td>      <td>5</td>      <td>4</td>      <td>3</td>      <td>2</td>      <td>1</td>      <td>0</td>      <td>8</td>      <td>7</td>      <td>6</td>      <td>5</td>      <td>4</td>      <td>3</td>      <td>2</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>Then the next state I will be...</th>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>Converting the 18 bits above to a hexadecimal number</th>      <td colspan="18"><p align="center">0b00 0001 1000 0000 1000</p>        <p align="center">0x1808</p></td>      </tr>  </tbody></table>这也被称为0x1808 rule, 还有其他的[interesting rule](https://en.wikipedia.org/wiki/Life-like_cellular_automaton#A_selection_of_Life-like_rules) ，修改hexadecimal number 的值即可(0x0 - 0x3FFFF) <h3 id="evaluateOneCell"><a href="#evaluateOneCell" class="headerlink" title="evaluateOneCell()"></a>evaluateOneCell()</h3><div class="note note-info">            <p>注意：测试的代码中颜色值只有255或0，255表示alive，0表示dead</p><p>三通道颜色（红，绿，蓝）要分别判断，即分别R,G,B是否存活，依据周围8个细胞的R,G,B状态 </p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> rx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> cx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><br>···<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>    <span class="hljs-type">int</span> new_row = ring(row+rx[i],image-&gt;rows);<br>    <span class="hljs-type">int</span> new_col = ring(col+cx[i],image-&gt;cols);<br></code></pre></td></tr></table></figure><p>周围8个细胞的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> idR = <span class="hljs-number">9</span>*isaliveR + aliveNeighbourR;<br><span class="hljs-keyword">if</span>(rule &amp; (<span class="hljs-number">1</span>&lt;&lt;idR))&#123;<br>    nextState-&gt;R = <span class="hljs-number">255</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    nextState-&gt;R = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据规则判断细胞是否存活</p><p>这样设计的原理如下</p><p><code>int idR = 9*isaliveR + aliveNeighbourR</code> :</p><p>首先<code>isaliveR</code>有两种状态0 和 1，<code>9 * isaliveR</code> 是决定状态的位置，注意上面的规则编码表格，每个细胞周围的细胞存活数有9种情况（0~8），使用<code>9 * isaliveR</code> 当<code>isaliveR = 0 </code>时，就处在<code>dead()</code>的范围</p><p>，加上<code>aliveNeighbourR</code>即可确定该细胞的状况，比如死亡周围有5个存活细胞。同理<code>isaliveR = 1</code>。</p><p><code>rule &amp; (1 &lt;&lt; idR)</code></p><p>1左移<code>idR</code>位，<code>idR = 4</code> 则 <code>1 &lt;&lt; 4</code>即 <code>0000 0000 0000 1000</code>，再跟<code>rule</code>取和，<code>0000 0000 0000 1000</code> 与 <code>0001 1000 0000 1000</code> 取和，得<code>0000 0000 0000 1000</code>。显然若结果不为零，则细胞下一代存活</p><h3 id="life-main"><a href="#life-main" class="headerlink" title="life() &amp; main()"></a>life() &amp; main()</h3><p>类似于<code>steganography()</code>的结构</p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-lab01</title>
    <link href="/2023/08/04/cs61c-lab01/"/>
    <url>/2023/08/04/cs61c-lab01/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab1-Number-Rep-C-and-CGDB"><a href="#Lab1-Number-Rep-C-and-CGDB" class="headerlink" title="Lab1: Number Rep, C and CGDB"></a>Lab1: Number Rep, C and CGDB</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) lab 笔记第一篇</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-lab">https://github.com/2333monster/my-cs61c-lab</a></p><p>参考</p><p>gdb调试手册：<a href="https://blog.nowcoder.net/n/1957d46e0ee34168aee2289faf36ee5c#gdb_20">https://blog.nowcoder.net/n/1957d46e0ee34168aee2289faf36ee5c#gdb_20</a></p><p>gdb调试指南：<a href="https://www.yanbinghu.com/2019/04/20/41283.html">https://www.yanbinghu.com/2019/04/20/41283.html</a></p></blockquote><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>获得skeleton code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ git remote add starter https://github.com/61c-teach/fa20-lab-starter.git<br>$ git pull starter master<br></code></pre></td></tr></table></figure><h2 id="Compiling-and-Running-a-C-Program"><a href="#Compiling-and-Running-a-C-Program" class="headerlink" title="Compiling and Running a C Program"></a>Compiling and Running a C Program</h2><p>使用gcc 编译c程序，生成执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ gcc hello.c<br></code></pre></td></tr></table></figure><p>使用执行文件<code>a.out</code>的名称运行c程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ ./a.out<br></code></pre></td></tr></table></figure><p>或者使用<code>-o</code>命令，它能指定执行文件的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ gcc -o hello hello.c<br>$ ./hello<br></code></pre></td></tr></table></figure><h2 id="Exercise-1-See-what-you-can-C"><a href="#Exercise-1-See-what-you-can-C" class="headerlink" title="Exercise 1: See what you can C"></a>Exercise 1: See what you can C</h2><p>本练习中，将看到宏定义处理器的示例</p><p>更改V0 ~ V3 的宏定义，使其输出以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">Berkeley eccentrics:<br>====================<br>Happy Happy Happy<br>Yoshua<br>Go BEARS!<br></code></pre></td></tr></table></figure><p>更改后（好像不要求完全不同，完全不同确实写不出来）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> V0 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V1 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V2 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V3 1</span><br></code></pre></td></tr></table></figure><h2 id="Exercise-2-Catch-those-bugs"><a href="#Exercise-2-Catch-those-bugs" class="headerlink" title="Exercise 2: Catch those bugs!"></a>Exercise 2: Catch those bugs!</h2><p>使用GDB进行Debug，<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/gdb5-refcard.pdf">GDB reference card</a></p><blockquote><p>GDB stands for “GNU De-Bugger.”</p></blockquote><p>使用<code>-g</code>调用 (c)gdb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -g -o hello hello.c</span><br></code></pre></td></tr></table></figure><p>这会生成一个可被<code>gdb</code>识别的可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb hello</span><br></code></pre></td></tr></table></figure><p><strong>gdb常用调试指令</strong></p><table><thead><tr><th>调试指令</th><th>作用</th></tr></thead><tbody><tr><td>b（break） 行号</td><td>在源代码指定的某一行设置断点，其中行号用于指定具体打断点的位置。</td></tr><tr><td>r（run）</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行。</td></tr><tr><td>n（next）(int)</td><td>令程序一行代码一行代码的执行。执行n次</td></tr><tr><td>p（print） 变量名</td><td>打印指定变量的值</td></tr><tr><td>l（list）</td><td>显示源程序代码的内容，包括各行代码所在的行号。</td></tr><tr><td>q（quit）</td><td>终止调试。</td></tr></tbody></table><p>断点设置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break location    //b 位置<br>(gdb) break ... if cond //b 表达式<br></code></pre></td></tr></table></figure><ul><li>location</li></ul><table><thead><tr><th>location 的值</th><th>含 义</th></tr></thead><tbody><tr><td>linenum</td><td>linenum 是一个整数，表示要打断点处代码的行号。</td></tr><tr><td>filename:linenum</td><td>filename 表示源程序文件名；linenum 为整数，表示具体行数。整体的意思是在指令文件 filename 中的第 linenum 行打断点。</td></tr><tr><td>+ offset</td><td>offset 为整数，+offset 表示以当前程序暂停位置为准，<strong>向后数</strong> offset 行处打断点</td></tr><tr><td>- offset</td><td>offset 为整数，-offset 表示以当前程序暂停位置为准，<strong>向前数</strong> offset 行处打断点</td></tr><tr><td>function</td><td>function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。</td></tr><tr><td>filename:function</td><td>filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。</td></tr></tbody></table><ul><li>cond 表达式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b 7 if num&gt;10  //如果num&gt;10 在第 7 行打断点<br></code></pre></td></tr></table></figure><h3 id="Action-Item"><a href="#Action-Item" class="headerlink" title="Action Item"></a>Action Item</h3><ol><li>setting a breakpoint at main</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b hello.c: main<br></code></pre></td></tr></table></figure><ol start="2"><li>using gdb’s run command</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run<br></code></pre></td></tr></table></figure><ol start="3"><li>using gdb’s single-step command</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n<br></code></pre></td></tr></table></figure><h4 id="gdb-questions"><a href="#gdb-questions" class="headerlink" title="gdb questions"></a>gdb questions</h4><ol><li><p>While you’re in a gdb session, how do you <strong>set the arguments</strong> that will be passed to the program when it’s run?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set args 5<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>create a breakpoint</strong>?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">b filename: linenum<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>execute the next line of C code</strong> in the program after stopping at a breakpoint?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n(next) / s(step)<br></code></pre></td></tr></table></figure></li><li><p>If the next line of code is a function call, you’ll execute the whole function call at once if you use your answer to #3. (If not, consider a different command for #3!) How do you tell GDB that you <strong>want to debug the code inside the function</strong> (i.e. step into the function) instead? (If you changed your answer to #3, then that answer is most likely now applicable here.)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">step<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>continue the program after stopping</strong> at a breakpoint?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run<br></code></pre></td></tr></table></figure></li><li><p>How can you <strong>print the value of a variable</strong> (or even an expression like 1+2) in gdb?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">p 1+2<br>p variable_name<br></code></pre></td></tr></table></figure></li><li><p>How do you configure gdb so it <strong>displays the value of a variable after every step</strong>?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">display variable<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>show a list of all variables and their values</strong> in the current function?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">info args<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>quit</strong> out of gdb?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">q<br></code></pre></td></tr></table></figure></li></ol><h2 id="Exercise-3-Debugging-w-YOU-ser-input"><a href="#Exercise-3-Debugging-w-YOU-ser-input" class="headerlink" title="Exercise 3: Debugging w&#x2F; YOU(ser input)"></a>Exercise 3: Debugging w&#x2F; YOU(ser input)</h2><p>好像是关于redirection ，没懂</p><h2 id="Exercise-4-Valgrind’ing-away"><a href="#Exercise-4-Valgrind’ing-away" class="headerlink" title="Exercise 4: Valgrind’ing away"></a>Exercise 4: Valgrind’ing away</h2><p>有两种bug类型</p><ol><li>bohrbugs：在一致的稳定的情况下会重复出现的错误</li><li>heisenbugs：在相同情况下不一定会重复出现，一般由于内存管理不当</li></ol><p>使用Valgrind 找出”heisenbugs” </p><blockquote><p>To help catch these “heisenbugs” we will use a tool called Valgrind. Valgrind is a program which emulates your CPU and tracks your memory accesses. This slows down the process you’re running (which is why we don’t, for example, always run all executables inside Valgrind) but also can expose bugs that may only display visible incorrect behavior under a unique set of circumstances.</p></blockquote><p>安装valgrind （在ubuntu环境下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install valgrind</span><br></code></pre></td></tr></table></figure><p><code>segfault_ex</code> 出现错误的原因</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;<br>        a[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问数组外未定义的内存，典型的heisenbug。</p><p><strong>使用valgrind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o segfault_ex.exe segfault_ex.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">valgrind ./segfault_ex.exe</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">==15931== Invalid write of size 4<br>==15931==   at 0x10914F: main (in /home/moxilai/cs61c-lab/lab01/segfault.exe)<br>==15931== Address 0x1fff001000 is not stack&#x27;d, malloc&#x27;d or (recently) free&#x27;d<br></code></pre></td></tr></table></figure><p><code>no_segfalut</code> 的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">unsigned</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(a); j++) &#123;<br>        total += a[j];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum of array is %d\n&quot;</span>, total);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for (int j = 0; j &lt; sizeof(a); j++)</code> 使用sizeof(a) a 是一个包含五个元素的整型数组，sizeof的结果是5*4&#x3D;20，而不是5，导致访问未定义的内存，从而产生未知的结果。这是一个典型的Heisenbug问题，因为其结果取决于内存中未定义的值，可能会导致程序崩溃或输出错误的结果。</p><p><strong>使用valgrind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o no_segfault.exe no_segfault_ex.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">valgrind ./no_segfault.exe</span><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D9B56: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Use of uninitialised value of size 8<br>==16089==    at 0x48BD33B: _itoa_word (_itoa.c:177)<br>==16089==    by 0x48D8B3D: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48BD34C: _itoa_word (_itoa.c:177)<br>==16089==    by 0x48D8B3D: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D9643: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D8C85: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br></code></pre></td></tr></table></figure><p>关键词：uninitialised value </p><p>分析上面两个程序</p><ol><li><p>Why <strong>didn’t</strong> the <code>no_segfault_ex</code> program segfault?<br>首先c以这种形式分配数组内存是stack中给了一个指针，随着j的增大，会访问a[5]~a[19]这实际是a+5 ~ a+19 的内存，这些内存是存在的，由于这不是分配给a 的内存，且没有初始化，其中会存储着脏数据，导致不可确定的。不过由于没有超出stack的容量，不会造成segfault（程序崩溃）</p></li><li><p>Why does the <code>no_segfault_ex</code> produce inconsistent outputs?<br>同上，不确定的数据导致不确定的输出</p></li><li><p>Why is <code>sizeof</code> incorrect? How could you still use <code>sizeof</code> but make the code correct?<br>同上，更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>arraylength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arraylength;j++)<br>    ...<br></code></pre></td></tr></table></figure></li></ol><h2 id="Exercise-5-Pointers-and-Structures-in-C"><a href="#Exercise-5-Pointers-and-Structures-in-C" class="headerlink" title="Exercise 5: Pointers and Structures in C"></a>Exercise 5: Pointers and Structures in C</h2><p>在ll_cycle.c中，完成函数ll_has_cycle()来实现以下检查单向链表是否有环的算法。</p><blockquote><ol><li>Start with two pointers at the head of the list. We’ll call the first one tortoise and the second one hare.</li><li>Advance hare by two nodes. If this is not possible because of a null pointer, we have found the end of the list, and therefore the list is acyclic.</li><li>Advance tortoise by one node.</li><li>If tortoise and hare point to the same node, the list is cyclic. Otherwise, go back to step 2.</li></ol></blockquote><p><code>ll_cycle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ll_cycle.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ll_has_cycle</span><span class="hljs-params">(node *head)</span> &#123;<br>    <span class="hljs-comment">/* your code here */</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    node *tortoise = head;<br>    node *hare = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(tortoise != <span class="hljs-literal">NULL</span> &amp;&amp; hare != <span class="hljs-literal">NULL</span> &amp;&amp; hare-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(tortoise == hare)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        tortoise = tortoise-&gt;next;<br>        hare = hare-&gt;next-&gt;next;<br>    &#125;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释算法原理<a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd.27s_Tortoise_and_Hare">Wikipedia article</a></p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参考.md</title>
    <link href="/2023/07/27/%E5%8F%82%E8%80%83/"/>
    <url>/2023/07/27/%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>hexo+github 部署个人网页 <a href="https://zhuanlan.zhihu.com/p/547520780">https://zhuanlan.zhihu.com/p/547520780</a></p><p>shell chmod 命令 <a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p><p>hexo 插入本地图片 解决了我的问题 <a href="https://www.jianshu.com/p/81191bc2cb2d">https://www.jianshu.com/p/81191bc2cb2d</a> 另一种方法: <a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cs61c-lec</title>
    <link href="/2023/08/09/cs61c-lec/"/>
    <url>/2023/08/09/cs61c-lec/</url>
    
    <content type="html"><![CDATA[<h1 id="Lec06-Floating-Point"><a href="#Lec06-Floating-Point" class="headerlink" title="Lec06 Floating Point"></a>Lec06 Floating Point</h1><ul><li><p>规格化</p><img src="/.io//08/09/cs61c-lec/Normalformat.jpg" class title="examplename"></li><li><p>overflow - underflow<br><img src="/.io//Overflow.png" alt="Overflow"></p></li><li><p>浮点数standard - sign exponent significand<br>![FP standard](FP standard.png)</p></li><li><p>IEEE 754 使用 “biased exponent” 表示 + 原因（P&amp;H p136)<br><img src="/.io//biasednotation.png" alt="biasednotation"></p></li><li><p>浮点数实际表示值（使用biased notation后）（-1)^S x (1+Significand) x 2^(Exponent-127)</p></li><li><p>FP 表示0；<code>infinity</code>；<code>NaN</code>(Not a Number) (<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/pdfs/lectures/lec06.pdf">sild lec06</a> p19-p23)</p></li><li><p>FP 表示<code>Denorms</code>(非规格化数) 重要理解  <a href="https://youtu.be/Gs0ARZzY-gM?list=PLnvUoC1Ghb7zz9gZ7A6DHo_YI7m_QtTwo&t=456">https://youtu.be/Gs0ARZzY-gM?list=PLnvUoC1Ghb7zz9gZ7A6DHo_YI7m_QtTwo&amp;t=456</a><br><img src="/.io//Denorms.png" alt="Denorms"></p></li><li><p>表示 1&#x2F;3</p></li><li><p>FP 加法不可交换</p></li><li><p>FP Precision &amp; Accuracy</p></li><li><p>舍入操作 （P &amp; H 3.5.7)<br><img src="/.io//round.png" alt="round"></p></li><li><p>由于浮点数的significand 每次加一后，对整个浮点数其实加1*2^(exponent+127)，所以它会跳过某些数</p><ul><li>因此，无法精确表示且将舍入的第一个整数是：<br>对于<code>float</code>而言，16,777,217（224 + 1）。<br>对于<code>double</code>而言，9,007,199,254,740,993（253 + 1 ）。<br><img src="/.io//simulator.png" alt="simulator"></li></ul></li><li><p><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE 754 simulator</a></p></li></ul><h1 id="Lec07-RISC-V-Intro"><a href="#Lec07-RISC-V-Intro" class="headerlink" title="Lec07 RISC-V Intro"></a>Lec07 RISC-V Intro</h1><ul><li><p>Risc-V 抽象层<br><img src="/.io//abstraction.png" alt="abstraction"></p></li><li><p>Risc-v -&gt; ISA(<em>Instrument Set Architecture</em>)<br><img src="/.io//assembly.png" alt="assembly"></p></li><li><p>寄存器(register)</p></li><li><p>基础操作符 - add sub addi</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-proj1</title>
    <link href="/2023/08/05/cs61c-proj1/"/>
    <url>/2023/08/05/cs61c-proj1/</url>
    
    <content type="html"><![CDATA[<h1 id="Project-1-Conway’s-Game-of-Life-in-RGB"><a href="#Project-1-Conway’s-Game-of-Life-in-RGB" class="headerlink" title="Project 1: Conway’s Game of Life, in RGB!"></a>Project 1: Conway’s Game of Life, in RGB!</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) proj1 笔记</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-proj">https://github.com/2333monster/my-cs61c-proj</a></p></blockquote><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><img src="https://inst.eecs.berkeley.edu/~cs61c/fa20/projects/proj1/conway.gif" alt="img" style="zoom: 25%;"><p>实现Game of LIfe.</p><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>原仓库设置为只读，我下载了源码解压</p><h3 id="PPM-Format"><a href="#PPM-Format" class="headerlink" title="PPM Format"></a>PPM Format</h3><p>PPM是一种存储图片的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PLaintext">P3<br>4 5<br>255<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>255 255 255   255 255 255   255 255 255     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br><br></code></pre></td></tr></table></figure><p>头部第一行 P3 -&gt; 这是一个P3格式的PPM 文件（还有5种格式）</p><p>头部第二行 4 5 -&gt; 图片 4 pixels 宽 5 pixels 高 </p><p>头部第三行 255 -&gt; 描述颜色值的范围 0~255</p><p>文件的余下部分是图片的实际像素，每个像素有三个数字描述分别代表红，绿，蓝</p><p>使用<code>convert</code> 命令转换.ppm格式到其他标准格式。</p><blockquote><p>The command <code>convert -compress none glider.png glider.ppm </code>can convert a png to a PPM P3 format, albeit with a different spacing convention than the one we will be using in this project. Similarly, the command <code>convert glider.ppm glider.png </code>can be used to convert a ppm back to a png. This can be useful for debugging purposes, and seeing the actual image files</p></blockquote><h3 id="File-I-O"><a href="#File-I-O" class="headerlink" title="File I&#x2F;O"></a>File I&#x2F;O</h3><p>以<code>Color</code>存储pixel 的颜色，<code>Image</code>形式存储所有图片</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Color</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint8_t</span> R;<br><span class="hljs-type">uint8_t</span> G;<br><span class="hljs-type">uint8_t</span> B;<br>&#125; Color;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Image</span></span><br><span class="hljs-class">&#123;</span><br>Color **image;<br><span class="hljs-type">uint32_t</span> rows;<br><span class="hljs-type">uint32_t</span> cols;<br>&#125; Image;<br></code></pre></td></tr></table></figure><p>使用file I&#x2F;O 管理文件 <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen</a> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose</a>  <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fscanf.htm">fscanf</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fopen opens a file pointer to the &quot;diary.txt&quot; file.</span><br><span class="hljs-comment">// The &quot;r&quot; indicates that the file should be opened in &quot;read mode&quot;.</span><br><span class="hljs-comment">// Other modes are detailed in the documentation linked above.</span><br>FILE *fp = fopen(<span class="hljs-string">&quot;diary.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-comment">// fscanf reads the first word and first number from the given file pointer into buf and num, respectively.</span><br><span class="hljs-comment">// The second argument is a string format, specifying what exactly fscanf should be reading from the file pointer.</span><br><span class="hljs-comment">// More options can for the string format can be found in the documentation linked above,</span><br><span class="hljs-comment">// but you may need to Google to figure out how to scan in specific types.</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> num;<br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%s %d&quot;</span>, buf, &amp;num);<br><br><span class="hljs-comment">// fclose simply closes the file pointer after we&#x27;re done with it.</span><br><span class="hljs-comment">// This frees the memory that fopen allocated for the file.</span><br><span class="hljs-comment">// This is also a necessary step whenever we are writing to a file:</span><br><span class="hljs-comment">// without closing the pointer, you may lose the last few lines</span><br><span class="hljs-comment">// you want to write.</span><br>fclose(fp);<br></code></pre></td></tr></table></figure><h2 id="Part-A1"><a href="#Part-A1" class="headerlink" title="Part A1"></a>Part A1</h2><p>实现见 <a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/imageloader.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/imageloader.c</a></p><h3 id="readData"><a href="#readData" class="headerlink" title="readData()"></a><strong>readData()</strong></h3><p>主要关注下分配空间，理清楚malloc()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Image *img = (Image*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Image));<br></code></pre></td></tr></table></figure><p>这里分配了一个 <code>Image</code>结构体的空间，用于存储图像的信息，包括图像的行数，列数，以及指向像素空间的指针<br>分配<code>sizeof(struct Image)</code>大小的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">img-&gt;image = (Color **)<span class="hljs-built_in">malloc</span>(totpixel*<span class="hljs-keyword">sizeof</span>(Color*));<br></code></pre></td></tr></table></figure><p>这里分配了一个指针数组，用于存储<code>Color</code>结构体的指针。</p><blockquote><p><code>img-&gt;image</code>为<code>Color **</code> 即 <code>img</code>是一个指向指针数组的指针，其中的每个指针指向一个<code>Color</code>对象</p></blockquote><p><code>Img</code>是一个<code>Color**</code> 类型，指向的对象是包含 <code>totpixel</code> 个 Color* 的指针数组<br>分配<code>totpixel*sizeof(Color *)</code> 大小的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;totpixel;i++)&#123;<br>    *(img-&gt;image+i) = (Color*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Color));`<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在上一步分配的指针数组中的每一个指针指向的位置，分配了一个<code>Color</code> 结构体的内存</p><p><code>*(img-&gt;image + i)</code> 是一个 <code>Color*</code> 类型，所以我们分配了 <code>sizeof(Color)</code> 字节的内存空间，来存储每个像素的颜色数据。</p><p>其次<code>fscanf</code>的参数我是根据<code>make imageloader</code>的报错结果修改的，我最开始是认为是<code>3u</code>的就是3位数的unit32，不理解<code>hhu</code>是什么原因。</p><div class="note note-info">            <p>注：hhu时unit8的读取</p>          </div><h3 id="WriteData-Free"><a href="#WriteData-Free" class="headerlink" title="WriteData() &amp; Free()"></a>WriteData() &amp; Free()</h3><p>逻辑上很简单，Free()的话，记得倒着释放，不然会找不到之后的地址。</p><h2 id="Part-A2"><a href="#Part-A2" class="headerlink" title="Part A2"></a>Part A2</h2><p>完成<code>Steganography</code>，完整见<a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/steganography.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/steganography.c</a></p><p>基于<a href="https://zh.wikipedia.org/wiki/%E9%9A%90%E5%86%99%E6%9C%AF">隐写术</a></p><blockquote><p>载体文件（cover file）相对隐秘文件的大小（指数据含量，以比特计）越大，隐藏后者就越加容易。</p><p>因为这个原因，数字图像（包含有大量的数据）在互联网和其他传媒上被广泛用于隐藏消息。这种方法使用的广泛程度无从查考。例如：一个24位的位图中的每个像素的三个颜色分量（红，绿和蓝）各使用8个比特来表示。如果我们只考虑蓝色的话，就是说有28种不同的数值来表示深浅不同的蓝色。而像11111111和11111110这两个值所表示的蓝色，人眼几乎无法区分。因此，这个最低有效位就可以用来存储颜色之外的信息，而且在某种程度上几乎是检测不到的。如果对红色和绿色进行同样的操作，就可以在差不多三个像素中存储一个字节的信息。</p><p>更正式一点地说，使隐写的信息难以探测的，也就是保证“有效载荷”（需要被隐蔽的信号）对“载体”（即原始的信号）的调制对载体的影响看起来（理想状况下甚至在统计上）可以忽略。这就是说，这种改变应该无法与载体中的噪声加以区别。</p><p>隐写术也可以用作电子水印，这里一条消息（往往只是一个标识符）被隐藏到一幅图像中，使得其来源能够被跟踪或校验。但往往隐写术不具有良好的强健性，当图像被稍微修改后，隐入的消息就无法提取校验了。</p></blockquote><h3 id="evaluateOnePixel"><a href="#evaluateOnePixel" class="headerlink" title="evaluateOnePixel"></a>evaluateOnePixel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据给定的图片和行列确定该位置像素的颜色，要求不影响原图片，给新的颜色分配空间</span><br>Color *<span class="hljs-title function_">evaluateOnePixel</span><span class="hljs-params">(Image *image, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span><br></code></pre></td></tr></table></figure><p>返回值是一个<code>Color *</code>，设置为<code>secret</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Color * secret = (Color *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Color));<br></code></pre></td></tr></table></figure><p>根据原理，确定该位置的颜色</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> LSB = (*p)-&gt;B &amp; <span class="hljs-number">1</span>;<br>secret-&gt;B = secret-&gt;G = secret-&gt;R = LSB*<span class="hljs-number">255</span>;<br></code></pre></td></tr></table></figure><h3 id="steganography"><a href="#steganography" class="headerlink" title="steganography"></a>steganography</h3><p>对每个像素分别调用<code>evaluateOnePixel</code>即可</p><div class="note note-info">            <p>完成part A2 时最好自己写测试，而不是使用make steganography命令，至少在我这里，这个命令会导致之前编译成功的<code>makeloader.c</code>的<code>fscanf</code>的参数出现问题。</p><p>另编译时，应该同时编译<code>steganography.c</code>和<code>makeloader.c</code>，因为<code>#include &quot;makeloader.h&quot;</code> 即</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o steganography steganography.c makeloader.c<br></code></pre></td></tr></table></figure>          </div><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>完成 <strong>The Game of Life</strong> 完整代码见<a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/gameoflife.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/gameoflife.c</a></p><blockquote><p>规则：</p><ol><li>任何一个周围（8个邻居中）有2或3个活细胞的活细胞，在下一代存活</li><li>任何一个周围有3个或者细胞邻居的死细胞，在下一代存活</li><li>所有其他类型的活细胞下一代带死亡，死细胞下一代仍死亡</li></ol></blockquote><p>规则编码</p><table>  <tbody>    <tr>      <th>If my state is...</th>      <th colspan="9"> alive (1)</th>      <th colspan="9"> dead (0)</th>    </tr>    <tr>      <th>And the number of alive neighbors is...</th>      <td>8</td>      <td>7</td>      <td>6</td>      <td>5</td>      <td>4</td>      <td>3</td>      <td>2</td>      <td>1</td>      <td>0</td>      <td>8</td>      <td>7</td>      <td>6</td>      <td>5</td>      <td>4</td>      <td>3</td>      <td>2</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>Then the next state I will be...</th>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>Converting the 18 bits above to a hexadecimal number</th>      <td colspan="18"><p align="center">0b00 0001 1000 0000 1000</p>        <p align="center">0x1808</p></td>      </tr>  </tbody></table>这也被称为0x1808 rule, 还有其他的[interesting rule](https://en.wikipedia.org/wiki/Life-like_cellular_automaton#A_selection_of_Life-like_rules) ，修改hexadecimal number 的值即可(0x0 - 0x3FFFF) <h3 id="evaluateOneCell"><a href="#evaluateOneCell" class="headerlink" title="evaluateOneCell()"></a>evaluateOneCell()</h3><div class="note note-info">            <p>注意：测试的代码中颜色值只有255或0，255表示alive，0表示dead</p><p>三通道颜色（红，绿，蓝）要分别判断，即分别R,G,B是否存活，依据周围8个细胞的R,G,B状态 </p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> rx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> cx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><br>···<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>    <span class="hljs-type">int</span> new_row = ring(row+rx[i],image-&gt;rows);<br>    <span class="hljs-type">int</span> new_col = ring(col+cx[i],image-&gt;cols);<br></code></pre></td></tr></table></figure><p>周围8个细胞的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> idR = <span class="hljs-number">9</span>*isaliveR + aliveNeighbourR;<br><span class="hljs-keyword">if</span>(rule &amp; (<span class="hljs-number">1</span>&lt;&lt;idR))&#123;<br>    nextState-&gt;R = <span class="hljs-number">255</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    nextState-&gt;R = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据规则判断细胞是否存活</p><p>这样设计的原理如下</p><p><code>int idR = 9*isaliveR + aliveNeighbourR</code> :</p><p>首先<code>isaliveR</code>有两种状态0 和 1，<code>9 * isaliveR</code> 是决定状态的位置，注意上面的规则编码表格，每个细胞周围的细胞存活数有9种情况（0~8），使用<code>9 * isaliveR</code> 当<code>isaliveR = 0 </code>时，就处在<code>dead()</code>的范围</p><p>，加上<code>aliveNeighbourR</code>即可确定该细胞的状况，比如死亡周围有5个存活细胞。同理<code>isaliveR = 1</code>。</p><p><code>rule &amp; (1 &lt;&lt; idR)</code></p><p>1左移<code>idR</code>位，<code>idR = 4</code> 则 <code>1 &lt;&lt; 4</code>即 <code>0000 0000 0000 1000</code>，再跟<code>rule</code>取和，<code>0000 0000 0000 1000</code> 与 <code>0001 1000 0000 1000</code> 取和，得<code>0000 0000 0000 1000</code>。显然若结果不为零，则细胞下一代存活</p><h3 id="life-main"><a href="#life-main" class="headerlink" title="life() &amp; main()"></a>life() &amp; main()</h3><p>类似于<code>steganography()</code>的结构</p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-lab01</title>
    <link href="/2023/08/04/cs61c-lab01/"/>
    <url>/2023/08/04/cs61c-lab01/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab1-Number-Rep-C-and-CGDB"><a href="#Lab1-Number-Rep-C-and-CGDB" class="headerlink" title="Lab1: Number Rep, C and CGDB"></a>Lab1: Number Rep, C and CGDB</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) lab 笔记第一篇</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-lab">https://github.com/2333monster/my-cs61c-lab</a></p><p>参考</p><p>gdb调试手册：<a href="https://blog.nowcoder.net/n/1957d46e0ee34168aee2289faf36ee5c#gdb_20">https://blog.nowcoder.net/n/1957d46e0ee34168aee2289faf36ee5c#gdb_20</a></p><p>gdb调试指南：<a href="https://www.yanbinghu.com/2019/04/20/41283.html">https://www.yanbinghu.com/2019/04/20/41283.html</a></p></blockquote><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>获得skeleton code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ git remote add starter https://github.com/61c-teach/fa20-lab-starter.git<br>$ git pull starter master<br></code></pre></td></tr></table></figure><h2 id="Compiling-and-Running-a-C-Program"><a href="#Compiling-and-Running-a-C-Program" class="headerlink" title="Compiling and Running a C Program"></a>Compiling and Running a C Program</h2><p>使用gcc 编译c程序，生成执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ gcc hello.c<br></code></pre></td></tr></table></figure><p>使用执行文件<code>a.out</code>的名称运行c程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ ./a.out<br></code></pre></td></tr></table></figure><p>或者使用<code>-o</code>命令，它能指定执行文件的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ gcc -o hello hello.c<br>$ ./hello<br></code></pre></td></tr></table></figure><h2 id="Exercise-1-See-what-you-can-C"><a href="#Exercise-1-See-what-you-can-C" class="headerlink" title="Exercise 1: See what you can C"></a>Exercise 1: See what you can C</h2><p>本练习中，将看到宏定义处理器的示例</p><p>更改V0 ~ V3 的宏定义，使其输出以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">Berkeley eccentrics:<br>====================<br>Happy Happy Happy<br>Yoshua<br>Go BEARS!<br></code></pre></td></tr></table></figure><p>更改后（好像不要求完全不同，完全不同确实写不出来）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> V0 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V1 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V2 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V3 1</span><br></code></pre></td></tr></table></figure><h2 id="Exercise-2-Catch-those-bugs"><a href="#Exercise-2-Catch-those-bugs" class="headerlink" title="Exercise 2: Catch those bugs!"></a>Exercise 2: Catch those bugs!</h2><p>使用GDB进行Debug，<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/gdb5-refcard.pdf">GDB reference card</a></p><blockquote><p>GDB stands for “GNU De-Bugger.”</p></blockquote><p>使用<code>-g</code>调用 (c)gdb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -g -o hello hello.c</span><br></code></pre></td></tr></table></figure><p>这会生成一个可被<code>gdb</code>识别的可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb hello</span><br></code></pre></td></tr></table></figure><p><strong>gdb常用调试指令</strong></p><table><thead><tr><th>调试指令</th><th>作用</th></tr></thead><tbody><tr><td>b（break） 行号</td><td>在源代码指定的某一行设置断点，其中行号用于指定具体打断点的位置。</td></tr><tr><td>r（run）</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行。</td></tr><tr><td>n（next）(int)</td><td>令程序一行代码一行代码的执行。执行n次</td></tr><tr><td>p（print） 变量名</td><td>打印指定变量的值</td></tr><tr><td>l（list）</td><td>显示源程序代码的内容，包括各行代码所在的行号。</td></tr><tr><td>q（quit）</td><td>终止调试。</td></tr></tbody></table><p>断点设置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break location    //b 位置<br>(gdb) break ... if cond //b 表达式<br></code></pre></td></tr></table></figure><ul><li>location</li></ul><table><thead><tr><th>location 的值</th><th>含 义</th></tr></thead><tbody><tr><td>linenum</td><td>linenum 是一个整数，表示要打断点处代码的行号。</td></tr><tr><td>filename:linenum</td><td>filename 表示源程序文件名；linenum 为整数，表示具体行数。整体的意思是在指令文件 filename 中的第 linenum 行打断点。</td></tr><tr><td>+ offset</td><td>offset 为整数，+offset 表示以当前程序暂停位置为准，<strong>向后数</strong> offset 行处打断点</td></tr><tr><td>- offset</td><td>offset 为整数，-offset 表示以当前程序暂停位置为准，<strong>向前数</strong> offset 行处打断点</td></tr><tr><td>function</td><td>function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。</td></tr><tr><td>filename:function</td><td>filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。</td></tr></tbody></table><ul><li>cond 表达式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b 7 if num&gt;10  //如果num&gt;10 在第 7 行打断点<br></code></pre></td></tr></table></figure><h3 id="Action-Item"><a href="#Action-Item" class="headerlink" title="Action Item"></a>Action Item</h3><ol><li>setting a breakpoint at main</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b hello.c: main<br></code></pre></td></tr></table></figure><ol start="2"><li>using gdb’s run command</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run<br></code></pre></td></tr></table></figure><ol start="3"><li>using gdb’s single-step command</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n<br></code></pre></td></tr></table></figure><h4 id="gdb-questions"><a href="#gdb-questions" class="headerlink" title="gdb questions"></a>gdb questions</h4><ol><li><p>While you’re in a gdb session, how do you <strong>set the arguments</strong> that will be passed to the program when it’s run?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set args 5<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>create a breakpoint</strong>?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">b filename: linenum<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>execute the next line of C code</strong> in the program after stopping at a breakpoint?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n(next) / s(step)<br></code></pre></td></tr></table></figure></li><li><p>If the next line of code is a function call, you’ll execute the whole function call at once if you use your answer to #3. (If not, consider a different command for #3!) How do you tell GDB that you <strong>want to debug the code inside the function</strong> (i.e. step into the function) instead? (If you changed your answer to #3, then that answer is most likely now applicable here.)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">step<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>continue the program after stopping</strong> at a breakpoint?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run<br></code></pre></td></tr></table></figure></li><li><p>How can you <strong>print the value of a variable</strong> (or even an expression like 1+2) in gdb?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">p 1+2<br>p variable_name<br></code></pre></td></tr></table></figure></li><li><p>How do you configure gdb so it <strong>displays the value of a variable after every step</strong>?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">display variable<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>show a list of all variables and their values</strong> in the current function?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">info args<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>quit</strong> out of gdb?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">q<br></code></pre></td></tr></table></figure></li></ol><h2 id="Exercise-3-Debugging-w-YOU-ser-input"><a href="#Exercise-3-Debugging-w-YOU-ser-input" class="headerlink" title="Exercise 3: Debugging w&#x2F; YOU(ser input)"></a>Exercise 3: Debugging w&#x2F; YOU(ser input)</h2><p>好像是关于redirection ，没懂</p><h2 id="Exercise-4-Valgrind’ing-away"><a href="#Exercise-4-Valgrind’ing-away" class="headerlink" title="Exercise 4: Valgrind’ing away"></a>Exercise 4: Valgrind’ing away</h2><p>有两种bug类型</p><ol><li>bohrbugs：在一致的稳定的情况下会重复出现的错误</li><li>heisenbugs：在相同情况下不一定会重复出现，一般由于内存管理不当</li></ol><p>使用Valgrind 找出”heisenbugs” </p><blockquote><p>To help catch these “heisenbugs” we will use a tool called Valgrind. Valgrind is a program which emulates your CPU and tracks your memory accesses. This slows down the process you’re running (which is why we don’t, for example, always run all executables inside Valgrind) but also can expose bugs that may only display visible incorrect behavior under a unique set of circumstances.</p></blockquote><p>安装valgrind （在ubuntu环境下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install valgrind</span><br></code></pre></td></tr></table></figure><p><code>segfault_ex</code> 出现错误的原因</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;<br>        a[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问数组外未定义的内存，典型的heisenbug。</p><p><strong>使用valgrind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o segfault_ex.exe segfault_ex.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">valgrind ./segfault_ex.exe</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">==15931== Invalid write of size 4<br>==15931==   at 0x10914F: main (in /home/moxilai/cs61c-lab/lab01/segfault.exe)<br>==15931== Address 0x1fff001000 is not stack&#x27;d, malloc&#x27;d or (recently) free&#x27;d<br></code></pre></td></tr></table></figure><p><code>no_segfalut</code> 的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">unsigned</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(a); j++) &#123;<br>        total += a[j];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum of array is %d\n&quot;</span>, total);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for (int j = 0; j &lt; sizeof(a); j++)</code> 使用sizeof(a) a 是一个包含五个元素的整型数组，sizeof的结果是5*4&#x3D;20，而不是5，导致访问未定义的内存，从而产生未知的结果。这是一个典型的Heisenbug问题，因为其结果取决于内存中未定义的值，可能会导致程序崩溃或输出错误的结果。</p><p><strong>使用valgrind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o no_segfault.exe no_segfault_ex.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">valgrind ./no_segfault.exe</span><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D9B56: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Use of uninitialised value of size 8<br>==16089==    at 0x48BD33B: _itoa_word (_itoa.c:177)<br>==16089==    by 0x48D8B3D: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48BD34C: _itoa_word (_itoa.c:177)<br>==16089==    by 0x48D8B3D: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D9643: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D8C85: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br></code></pre></td></tr></table></figure><p>关键词：uninitialised value </p><p>分析上面两个程序</p><ol><li><p>Why <strong>didn’t</strong> the <code>no_segfault_ex</code> program segfault?<br>首先c以这种形式分配数组内存是stack中给了一个指针，随着j的增大，会访问a[5]~a[19]这实际是a+5 ~ a+19 的内存，这些内存是存在的，由于这不是分配给a 的内存，且没有初始化，其中会存储着脏数据，导致不可确定的。不过由于没有超出stack的容量，不会造成segfault（程序崩溃）</p></li><li><p>Why does the <code>no_segfault_ex</code> produce inconsistent outputs?<br>同上，不确定的数据导致不确定的输出</p></li><li><p>Why is <code>sizeof</code> incorrect? How could you still use <code>sizeof</code> but make the code correct?<br>同上，更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>arraylength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arraylength;j++)<br>    ...<br></code></pre></td></tr></table></figure></li></ol><h2 id="Exercise-5-Pointers-and-Structures-in-C"><a href="#Exercise-5-Pointers-and-Structures-in-C" class="headerlink" title="Exercise 5: Pointers and Structures in C"></a>Exercise 5: Pointers and Structures in C</h2><p>在ll_cycle.c中，完成函数ll_has_cycle()来实现以下检查单向链表是否有环的算法。</p><blockquote><ol><li>Start with two pointers at the head of the list. We’ll call the first one tortoise and the second one hare.</li><li>Advance hare by two nodes. If this is not possible because of a null pointer, we have found the end of the list, and therefore the list is acyclic.</li><li>Advance tortoise by one node.</li><li>If tortoise and hare point to the same node, the list is cyclic. Otherwise, go back to step 2.</li></ol></blockquote><p><code>ll_cycle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ll_cycle.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ll_has_cycle</span><span class="hljs-params">(node *head)</span> &#123;<br>    <span class="hljs-comment">/* your code here */</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    node *tortoise = head;<br>    node *hare = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(tortoise != <span class="hljs-literal">NULL</span> &amp;&amp; hare != <span class="hljs-literal">NULL</span> &amp;&amp; hare-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(tortoise == hare)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        tortoise = tortoise-&gt;next;<br>        hare = hare-&gt;next-&gt;next;<br>    &#125;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释算法原理<a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd.27s_Tortoise_and_Hare">Wikipedia article</a></p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参考.md</title>
    <link href="/2023/07/27/%E5%8F%82%E8%80%83/"/>
    <url>/2023/07/27/%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>hexo+github 部署个人网页 <a href="https://zhuanlan.zhihu.com/p/547520780">https://zhuanlan.zhihu.com/p/547520780</a><br>shell chmod 命令 <a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

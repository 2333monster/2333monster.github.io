<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cs61c-lab03</title>
    <link href="/2023/08/16/cs61c-lab03/"/>
    <url>/2023/08/16/cs61c-lab03/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab-3-RISCV-Assembly"><a href="#Lab-3-RISCV-Assembly" class="headerlink" title="Lab 3: RISCV Assembly"></a>Lab 3: RISCV Assembly</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) lab 笔记第二篇</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-lab">https://github.com/2333monster/my-cs61c-lab</a></p></blockquote><p><em>lab3</em> 熟悉编写 RISC-V 并使用 Venus 模拟器 <a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources/venus-reference">Venus reference</a>，先硬着头皮做的proj2A，被折磨了两天，现在在写这些基础的确实觉得很简单，不过先写了lab3应该对proj2有些帮助，可以说是前置。</p><h2 id="Exercise-0-Connecting-your-files-to-Venus"><a href="#Exercise-0-Connecting-your-files-to-Venus" class="headerlink" title="Exercise 0: Connecting your files to Venus"></a>Exercise 0: Connecting your files to Venus</h2><p>注意lab03好像默认是没有tools&#x2F;venus.jar 这个文件的，可以从sp22的proj2复制一个</p><p>将文件链接到_Venus_， 在lab文件下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>terminal -&gt; java -jar tools/venus.jar . -dm<br>venus -&gt; mount local vmfs<br></code></pre></td></tr></table></figure><h2 id="Exercise-1-Familiarizing-yourself-with-Venus"><a href="#Exercise-1-Familiarizing-yourself-with-Venus" class="headerlink" title="Exercise 1: Familiarizing yourself with Venus"></a>Exercise 1: Familiarizing yourself with Venus</h2><ol><li>What do the <code>.data</code>, <code>.word</code>, <code>.text</code> directives mean (i.e. what do you use them for)? <strong>Hint</strong>: think about the 4 sections of memory.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Pliantext">.data : 这是一个数据段的声明，用于存储程序中的数据<br>.word 2, 4, 6, 8: 这个指令在数据段中分别存储了四个字（32位）的数据，具体是 2, 4, 6, 8<br>0x1000000 - 0x1000000c<br>n: .word 9：这个指令在数据段中创建了一个标签 n，并在 n 处存储了一个字的数据，即 9<br>0x10000010 <br></code></pre></td></tr></table></figure><ol start="2"><li>Run the program to completion. What number did the program output? What does this number represent?</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">34 9th fibonacci 数<br></code></pre></td></tr></table></figure><ol start="3"><li>At what address is <code>n</code> stored in memory? <strong>Hint</strong>: Look at the contents of the registers.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Pliantext">0x10000010 <br></code></pre></td></tr></table></figure><ol start="4"><li>Without actually editing the code (i.e. without going into the “Editor” tab), have the program calculate the 13th fib number (0-indexed) by <em>manually</em> modifying the value of a register. You may find it helpful to first step through the code. If you prefer to look at decimal values, change the “Display Settings” option at the bottom.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Pliantext">n: .word 9 -&gt; n: .word 13<br></code></pre></td></tr></table></figure><h2 id="Exercise-2-Translating-from-C-to-RISC-V"><a href="#Exercise-2-Translating-from-C-to-RISC-V" class="headerlink" title="Exercise 2: Translating from C to RISC-V"></a>Exercise 2: Translating from C to RISC-V</h2><p><code>ex2.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> source[] = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dest[<span class="hljs-number">10</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><span class="hljs-keyword">return</span> -x * (x + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; source[k] != <span class="hljs-number">0</span>; k++) &#123;<br>        dest[k] = fun(source[k]);<br>        sum += dest[k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ex2.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl main<br><br>.data<br>source:<br>    .word   3<br>    .word   1<br>    .word   4<br>    .word   1<br>    .word   5<br>    .word   9<br>    .word   0<br>dest:<br>    .word   0<br>    .word   0<br>    .word   0<br>    .word   0<br>    .word   0<br>    .word   0<br>    .word   0<br>    .word   0<br>    .word   0<br>    .word   0<br><br>.text<br>fun:<br>    addi t0, a0, 1<br>    sub t1, x0, a0<br>    mul a0, t0, t1<br>    jr ra<br><br>main:<br>    # BEGIN PROLOGUE<br>    addi sp, sp, -20<br>    sw s0, 0(sp)<br>    sw s1, 4(sp)<br>    sw s2, 8(sp)<br>    sw s3, 12(sp)<br>    sw ra, 16(sp)<br>    # END PROLOGUE<br>    addi t0, x0, 0<br>    addi s0, x0, 0<br>    la s1, source<br>    la s2, dest<br>loop:<br>    slli s3, t0, 2# 4*k index step<br>    add t1, s1, s3# &amp;source[k]<br>    lw t2, 0(t1)# source[k]<br>    beq t2, x0, exit# source[k] != 0<br>    add a0, x0, t2# a0 = source[k] prepare for fun() argument<br>    addi sp, sp, -8# store registers<br>    sw t0, 0(sp)<br>    sw t2, 4(sp)<br>    jal fun# call fun()<br>    lw t0, 0(sp)<br>    lw t2, 4(sp)<br>    addi sp, sp, 8# recover registers<br>    add t2, x0, a0# t2 = fun(source[k]), a0 已经是返回值了<br>    add t3, s2, s3# t3 = &amp;dest[k]<br>    sw t2, 0(t3)# dest[k] = fun(source[k])<br>    add s0, s0, t2# sum += dest[k]<br>    addi t0, t0, 1# k++<br>    jal x0, loop<br>exit:<br>    add a0, x0, s0<br>    # BEGIN EPILOGUE<br>    lw s0, 0(sp)<br>    lw s1, 4(sp)<br>    lw s2, 8(sp)<br>    lw s3, 12(sp)<br>    lw ra, 16(sp)<br>    addi sp, sp, 20<br>    # END EPILOGUE<br>    jr ra<br><br></code></pre></td></tr></table></figure><ol><li>The register representing the variable <code>k</code>.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">t0<br></code></pre></td></tr></table></figure><ol start="2"><li>The register representing the variable <code>sum</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Pliantext">s0<br></code></pre></td></tr></table></figure><ol start="3"><li>The registers acting as pointers to the <code>source</code> and <code>dest</code> arrays.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">la s1, source -&gt; load address of source<br>la s2, dest<br></code></pre></td></tr></table></figure><ol start="4"><li>The assembly code for the loop found in the C code</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">loop:<br>...<br>beq t2, x0, <span class="hljs-keyword">exit</span><span class="hljs-comment"># source[k] != 0</span><br>...<br>addi t0, t0, <span class="hljs-number">1</span><span class="hljs-comment"># k++</span><br>...<br>jal x0, loop<br></code></pre></td></tr></table></figure><ol start="5"><li>How the pointers are manipulated in the assembly code.</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">slli </span><span class="hljs-built_in">s3</span>, <span class="hljs-built_in">t0</span>, <span class="hljs-number">2</span><span class="hljs-comment"># 4*k index step</span><br><span class="hljs-keyword">add </span><span class="hljs-built_in">t1</span>, <span class="hljs-built_in">s1</span>, <span class="hljs-built_in">s3</span><span class="hljs-comment"># &amp;source[k]</span><br><span class="hljs-keyword">lw </span><span class="hljs-built_in">t2</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">t1</span>)<span class="hljs-comment"># source[k]</span><br></code></pre></td></tr></table></figure><h2 id="Exercise-3-Factorial"><a href="#Exercise-3-Factorial" class="headerlink" title="Exercise 3: Factorial"></a>Exercise 3: Factorial</h2><p>递归：</p><p><code>factorial.c</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n * factorial(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>factorial.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.globl factorial<br><br>.data<br>n: .word 8<br><br>.text<br>main:<br>    la t0, n<br>    lw a0, 0(t0)<br>    jal ra, factorial<br><br>    addi a1, a0, 0<br>    addi a0, x0, 1<br>    ecall # Print Result<br><br>    addi a1, x0, &#x27;\n&#x27;<br>    addi a0, x0, 11<br>    ecall # Print newline<br><br>    addi a0, x0, 10<br>    ecall # Exit<br><br>factorial:<br>    bnez a0, L        # 如果 a0 非零，跳转到 .L1 标签<br>    li a0, 1           # 如果 a0 为零，将 a0 设为 1<br>    ret<br><br>L:<br># prologue<br>    addi sp, sp, -8      # 分配堆栈空间<br>    sw ra, 0(sp)       # 保存 ra 寄存器<br>    sw a0, 4(sp)       # 保存 a0 寄存器<br><br>    li a1, 1           # 加载立即数 1 到 a1<br>    sub a0, a0, a1      # 计算 n - 1，并将结果保存在 a0<br><br>    jal factorial       # 递归调用 factorial 函数，将结果保存在 a0<br>    <br>    add t0, x0, a0<br>    # epilogue<br>    lw a0, 4(sp)       # 恢复 a0 寄存器的值<br>    lw ra, 0(sp)       # 恢复 ra 寄存器的值<br>    addi sp, sp, 8      # 释放堆栈空间<br><br>    mul     a0, t0, a0      # 计算 n * (n - 1) 的结果，并保存在 a0<br>    ret<br></code></pre></td></tr></table></figure><p>迭代：</p><p><code>factoria.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> a0)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> t1 = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (a0 != <span class="hljs-number">0</span>) &#123;<br>        t1 = t1 * a0;<br>        a0 = a0 - <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> t1;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>factoria.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">factorial:<br>    addi t1, x0, 1<br>loop:    <br>    beq a0, x0, _get_out<br>    mul t1, t1, a0<br>    addi a0, a0, -1<br>    jal x0, loop<br>_get_out:<br>    mv a0, t1<br>    ret<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>显然迭代貌似更好写</p>          </div><h2 id="Exercise-4-Calling-Convention-Checker"><a href="#Exercise-4-Calling-Convention-Checker" class="headerlink" title="Exercise 4: Calling Convention Checker"></a>Exercise 4: Calling Convention Checker</h2><p>修复约定检查器检测出的违规行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">[CC Violation]: (PC=0x00000080) Usage of unset register t0! cc_test.s:58 mv a0, t0<br>[CC Violation]: (PC=0x0000008C) Setting of a saved register (s0) which has not been saved! cc_test.s:80 li s0, 1<br>[CC Violation]: (PC=0x00000094) Setting of a saved register (s0) which has not been saved! cc_test.s:83 mul s0, s0, a0<br>[CC Violation]: (PC=0x00000094) Setting of a saved register (s0) which has not been saved! cc_test.s:83 mul s0, s0, a0<br>[CC Violation]: (PC=0x00000094) Setting of a saved register (s0) which has not been saved! cc_test.s:83 mul s0, s0, a0<br>[CC Violation]: (PC=0x00000094) Setting of a saved register (s0) which has not been saved! cc_test.s:83 mul s0, s0, a0<br>[CC Violation]: (PC=0x00000094) Setting of a saved register (s0) which has not been saved! cc_test.s:83 mul s0, s0, a0<br>[CC Violation]: (PC=0x00000094) Setting of a saved register (s0) which has not been saved! cc_test.s:83 mul s0, s0, a0<br>[CC Violation]: (PC=0x00000094) Setting of a saved register (s0) which has not been saved! cc_test.s:83 mul s0, s0, a0<br>[CC Violation]: (PC=0x000000A4) Save register s0 not correctly restored before return! Expected 0x00000A3F, Actual 0x00000080. cc_test.s:90 ret<br>[CC Violation]: (PC=0x000000B0) Setting of a saved register (s0) which has not been saved! cc_test.s:106 mv s0, a0 # Copy start of array to saved register<br>[CC Violation]: (PC=0x000000B4) Setting of a saved register (s1) which has not been saved! cc_test.s:107 mv s1, a1 # Copy length of array to saved register<br>[CC Violation]: (PC=0x000000E4) Setting of a saved register (s0) which has not been saved! cc_test.s:142 addi s0, t1, 1<br>Venus ran into a simulator error!<br>Attempting to access uninitialized memory between the stack and heap. Attempting to access &#x27;4&#x27; bytes at address &#x27;0x14B7A3FD&#x27;.<br></code></pre></td></tr></table></figure><p>添加了些存储sp</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Sanity</span> checks passed! Make sure there are <span class="hljs-literal">no</span> CC violations.<br></code></pre></td></tr></table></figure><h2 id="Exercise-5-RISC-V-function-calling-with-map"><a href="#Exercise-5-RISC-V-function-calling-with-map" class="headerlink" title="Exercise 5: RISC-V function calling with map"></a>Exercise 5: RISC-V function calling with <code>map</code></h2><p>finish</p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-proj2</title>
    <link href="/2023/08/12/cs61c-proj2/"/>
    <url>/2023/08/12/cs61c-proj2/</url>
    
    <content type="html"><![CDATA[<h1 id="Project-2-CS61Classify"><a href="#Project-2-CS61Classify" class="headerlink" title="Project 2: CS61Classify"></a>Project 2: CS61Classify</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) proj2 笔记</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-proj">https://github.com/2333monster/my-cs61c-proj</a></p><p>注：是sp22 的proj2</p></blockquote><h2 id="Part-A-Math-Functions"><a href="#Part-A-Math-Functions" class="headerlink" title="Part A: Math Functions"></a>Part A: Math Functions</h2><p> 完成</p><ul><li>abs</li><li>dot product</li><li>matrix multiplication</li><li>an element-wise rectifier function (ReLU)</li><li>an argmax function for vectors.</li></ul><h3 id="Task-1-Absolute-Value-Walkthrough"><a href="#Task-1-Absolute-Value-Walkthrough" class="headerlink" title="Task 1: Absolute Value (Walkthrough)"></a>Task 1: Absolute Value (Walkthrough)</h3><p>熟悉工作流</p><h4 id="Running-Tests"><a href="#Running-Tests" class="headerlink" title="Running Tests"></a>Running Tests</h4><p>在linux 环境下，进行操作即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash test.sh<br>bash test.sh part_a <br>bash test.sh test_abs<br></code></pre></td></tr></table></figure><h4 id="Using-VDB-to-debug-tests-via-Venus"><a href="#Using-VDB-to-debug-tests-via-Venus" class="headerlink" title="Using VDB to debug tests via Venus"></a>Using VDB to debug tests via Venus</h4><p>根据<a href="https://inst.eecs.berkeley.edu/~cs61c/sp22/projects/proj2/#setup-venus">the setup section of the spec</a> 设置venus，注意在linux 下即可</p><p>在&#x2F;src&#x2F;abs.s 中添加ebreak</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">abs:<br># Prologue<br>    ebreak<br># PASTE HERE<br><br>    blt a0, zero, done<br><br>    # Negate a0<br>    sub a0, x0, a0<br><br>done:<br>  ret<br># Epilogue<br></code></pre></td></tr></table></figure><p>在terminal 中，运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /vmfs/test-src<br>vdb test_abs_one.s <br></code></pre></td></tr></table></figure><p>然后再simulator 中debug就好，发现错误后（大于0但是取了相反数），修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">abs:<br># Prologue<br>    ebreak<br># PASTE HERE<br><br>    bge a0, zero, done<br><br>    # Negate a0<br>    sub a0, x0, a0<br><br>done:<br>  ret<br># Epilogue<br></code></pre></td></tr></table></figure><h3 id="Task-2-ReLU"><a href="#Task-2-ReLU" class="headerlink" title="Task 2: ReLU"></a>Task 2: ReLU</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs assembly">relu:<br>    # ebreak<br># Prologue<br>    li t5,1<br>    blt a1,t5,exit_relu<br>    add t0, x0,x0<br>    addi t2, x0, 4<br>loop_start:<br>beq t0, a1, loop_end<br>mul t1, t0, t2<br>    add t3, a0, t1<br>    lw t4, 0(t3)<br>bgt t4, x0, loop_continue<br>sw zero, 0(t3)<br>loop_continue:<br>addi t0, t0, 1<br>j loop_start<br>loop_end:<br># Epilogue<br>ret<br>exit_relu:<br>    li a0 36<br>    j exit<br></code></pre></td></tr></table></figure><h3 id="Task-3-Argmax"><a href="#Task-3-Argmax" class="headerlink" title="Task 3: Argmax"></a>Task 3: Argmax</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">argmax:<br>    ebreak<br>    # Prologue<br>    li t5, 1<br>    blt a1, t5, exit_argmax<br>    li t0,0         #max_index<br>    lw t1,0(a0)     #max_value<br>    add t2,x0,x0    #i<br>    li t5,4<br>loop_start:<br>    beq t2,a1,loop_end<br>    mul t4,t2,t5    #4i<br>    add t6,a0,t4    #&amp;a0[i]<br>    lw t3,0(t6)     #a0[i]<br>    bge t1,t3,loop_continue<br>    mv t1,t3<br>    mv t0,t2<br>loop_continue:<br>    addi t2,t2,1<br>    j loop_start<br>exit_argmax:<br>    li a0,36<br>    j exit<br>loop_end:<br>    mv a0,t0<br>    ret<br></code></pre></td></tr></table></figure><h3 id="Task-4-Dot-Product"><a href="#Task-4-Dot-Product" class="headerlink" title="Task 4: Dot Product"></a>Task 4: Dot Product</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dot:<br>ebreak<br># Prologue<br>li t5,1<br>blt a2,t5,exit_36<br>blt a3,t5,exit_37<br>blt a4,t5,exit_37<br>li t0,0 #result<br>li t1,0 #i<br>slli a3,a3,2<br>slli a4,a4,2<br>loop_start:<br>beq t1,a2,loop_end<br>lw t2,0(a0)<br>lw t3,0(a1)<br><br>mul t4,t2,t3<br>add t0,t0,t4<br><br>add a0,a0,a3<br>add a1,a1,a4<br>addi t1,t1,1<br>j loop_start<br>exit_36:<br>li a0 36<br>j exit<br>exit_37:<br>li a0 37<br>j exit<br>loop_end:<br># Epilogue<br>mv a0 t0<br>ret<br></code></pre></td></tr></table></figure><h3 id="Task5-Matrix-Multiplication"><a href="#Task5-Matrix-Multiplication" class="headerlink" title="Task5: Matrix Multiplication"></a>Task5: Matrix Multiplication</h3><p>做了好久，刚开始写确实很乱，静下心梳理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs assembly">matmul:<br>ebreak<br># Error checks<br>li t5, 1<br>blt a1, t5, exit_38<br>blt a2, t5, exit_38<br>blt a4, t5, exit_38<br>blt a5, t5, exit_38<br>bne a2, a4, exit_38<br><br># Prologue<br>addi sp, sp, -16<br>sw s0, 0(sp)<br>sw s1, 4(sp)<br>sw s2, 8(sp)<br>sw s3, 12(sp)<br>li s0, 0     # i<br>li s1, 0     # j<br><br>outer_loop_start:<br>li s1, 0<br><br>inner_loop_start:<br># save context<br>addi sp, sp, -32<br>sw ra, 0(sp)<br>sw a0, 4(sp)<br>sw a1, 8(sp)<br>sw a2, 12(sp)<br>sw a3, 16(sp)<br>sw a4, 20(sp)<br>sw a5, 24(sp)<br>sw a6, 28(sp)<br><br># set arguments for dot function<br>addi t4, x0, 4<br>mul t4, t4, s1<br>add a1, a3, t4<br>li a3, 1<br>mv a4, a5<br><br># call dot function<br>jal dot<br><br># get answer<br>mv t1, a0<br><br># restore context<br>lw ra, 0(sp)<br>lw a0, 4(sp)<br>lw a1, 8(sp)<br>lw a2, 12(sp)<br>lw a3, 16(sp)<br>lw a4, 20(sp)<br>lw a5, 24(sp)<br>lw a6, 28(sp)<br>addi sp, sp, 32<br><br># store result in the result matrix d<br>mul t2, s0, a5<br>add t2, t2, s1<br>addi t4, x0, 4<br>mul t2, t2, t4<br>add t2, a6, t2<br>sw t1, 0(t2)<br><br>inner_loop_end:<br>addi s1, s1, 1<br>beq s1, a5, outer_loop_end<br>j inner_loop_start<br><br>outer_loop_end:<br>addi s0, s0, 1<br>addi t4, x0, 4<br>mul t0, t4, a2<br>add a0, a0, t0<br>beq s0, a1, end<br>j outer_loop_start<br><br><br>end:<br># Epilogue<br>lw s0, 0(sp)<br>lw s1, 4(sp)<br>lw s2, 8(sp)<br>lw s3, 12(sp)<br>addi sp, sp, 16<br>ret<br><br>exit_38:<br>li a0, 38<br>j exit<br></code></pre></td></tr></table></figure><p><strong>代码思路</strong></p><ol><li>首先，代码进行维度检查，确保输入矩阵的维度是有效的，如果任何一个维度小于1，则跳转到 <code>exit_38</code> 标签，终止程序。</li><li>然后，代码初始化一些寄存器和变量，为循环做准备。<code>s0</code> 用于追踪当前行，<code>s1</code> 用于追踪当前列。</li><li>进入外层循环 <code>outer_loop_start</code>，其中 <code>s0</code> 追踪矩阵 <code>m0</code> 的当前行。然后，进入内层循环 <code>inner_loop_start</code>，其中 <code>s1</code> 追踪矩阵 <code>m1</code> 的当前列。</li><li>在内层循环内，首先保存寄存器上下文，然设置<code>dot</code>函数的参数。<code>a0</code>不变，计算 <code>a1</code> 的地址（<code>a1</code> 是矩阵 <code>m1</code> 当前列的起始地址），<code>a2</code>不变，设置 <code>a3</code> 为 1，将 <code>a4</code> 设置为矩阵 <code>m1</code> 的列数。</li><li>调用 <code>dot</code> 函数，将矩阵 <code>m0</code> 的当前行和矩阵 <code>m1</code> 的当前列进行点积运算，结果保存在 <code>t1</code> 中。</li><li>恢复寄存器上下文，然后将 <code>t1</code> 的值存储在结果矩阵 <code>d</code> 中的对应位置。</li><li>内层循环结束后，增加 <code>s1</code> 的值，如果 <code>s1</code> 小于矩阵 <code>m1</code> 的列数，则继续内层循环。</li><li>外层循环结束后，增加 <code>s0</code> 的值，然后将 <code>a0</code> 更新为下一行的起始地址。如果 <code>s0</code> 小于矩阵 <code>m0</code> 的行数，则继续外层循环。</li><li>循环结束后，恢复寄存器上下文并返回。</li><li>如果发现维度无效，则跳转到 <code>exit_38</code>，程序终止。</li></ol><p><strong>计算a1地址</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">addi t4, x0, 4<br>mul t4, t4, s1<br>add a1, a3, t4<br></code></pre></td></tr></table></figure><p><strong>计算结果存储在结果矩阵d 的相对位置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mul t2, s0, a5<br>add t2, t2, s1<br>addi t4, x0, 4<br>mul t2, t2, t4<br>add t2, a6, t2<br>sw t1, 0(t2)<br></code></pre></td></tr></table></figure><ol><li><code>mul t2, s0, a5</code>: 这行代码计算了要存储的元素在结果矩阵 <code>d</code> 中的行号。<code>s0</code> 包含了当前正在计算的行号，而 <code>a5</code> 包含了矩阵 <code>m1</code> 的列数（也是结果矩阵 <code>d</code> 的列数）。将这两个值相乘，得到的结果存储在寄存器 <code>t2</code> 中。</li><li><code>add t2, t2, s1</code>: 这行代码将刚刚计算的行号 <code>t2</code> 与当前正在计算的列号 <code>s1</code> 相加。这是为了计算出在结果矩阵 <code>d</code> 中的具体位置。</li><li><code>addi t4, x0, 4</code>: 这行代码将立即数 4 存储在寄存器 <code>t4</code> 中。这是因为每个元素占用 4 个字节（假设是 32 位整数）。</li><li><code>mul t2, t2, t4</code>: 这行代码将刚刚计算的位置 <code>t2</code> 与每个元素的大小相乘，以得到字节偏移量。</li><li><code>add t2, a6, t2</code>: 这行代码将字节偏移量 <code>t2</code> 与结果矩阵 <code>d</code> 的起始地址相加，从而得到最终要存储的地址。</li><li><code>sw t1, 0(t2)</code>: 这行代码使用 <code>sw</code> 指令，将点积运算的结果 <code>t1</code> 存储在刚刚计算出的地址上，从而将计算结果存储在结果矩阵 <code>d</code> 中的对应位置。</li></ol><p><strong>更新矩阵a0 的行指针，以便在下一次循环中处理下一行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">addi t4, x0, 4<br>mul t0, t4, a2<br>add a0, a0, t0<br></code></pre></td></tr></table></figure><ol><li><code>addi t4, x0, 4</code>: 这行代码将立即数 4 存储在寄存器 <code>t4</code> 中。这是因为每个元素占用 4 个字节（假设是 32 位整数）。</li><li><code>mul t0, t4, a2</code>: 这行代码将刚刚存储在寄存器 <code>t4</code> 中的值（即每个元素的大小）与矩阵 <code>m0</code> 的列数 <code>a2</code> 相乘，得到的结果存储在寄存器 <code>t0</code> 中。这是为了计算当前行中下一个元素的偏移量。</li><li><code>add a0, a0, t0</code>: 这行代码将刚刚计算出的偏移量 <code>t0</code> 加到矩阵 <code>m0</code> 的起始地址 <code>a0</code> 上，以更新行指针。这将使指针指向下一行的开头，以便在下一次循环中处理下一行</li></ol><h2 id="Part-B-File-Operations-and-Classification"><a href="#Part-B-File-Operations-and-Classification" class="headerlink" title="Part B: File Operations and Classification"></a>Part B: File Operations and Classification</h2>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-lab02</title>
    <link href="/2023/08/10/cs61c-lab02/"/>
    <url>/2023/08/10/cs61c-lab02/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab-2-Advanced-C"><a href="#Lab-2-Advanced-C" class="headerlink" title="Lab 2: Advanced C"></a>Lab 2: Advanced C</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) lab 笔记第二篇</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-lab">https://github.com/2333monster/my-cs61c-lab</a></p></blockquote><h2 id="Exercise-0-Makefiles"><a href="#Exercise-0-Makefiles" class="headerlink" title="Exercise 0: Makefiles"></a>Exercise 0: Makefiles</h2><p>makefile教程：<a href="https://seisman.github.io/how-to-write-makefile/introduction.html">https://seisman.github.io/how-to-write-makefile/introduction.html</a></p><img src="/2023/08/10/cs61c-lab02/makefile.png" class=""><h2 id="Exercise-1-Bit-Operations"><a href="#Exercise-1-Bit-Operations" class="headerlink" title="Exercise 1: Bit Operations"></a>Exercise 1: Bit Operations</h2><p>完成<code>get_bit</code>, <code>set_bit</code>, and <code>flip_bit</code></p><p>独立完成后，查看别人的实现学习到了更简洁更直观的表达，就理下别人的思路</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> x,</span><br><span class="hljs-params">                 <span class="hljs-type">unsigned</span> n)</span> &#123;<br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    <span class="hljs-comment">// Returning -1 is a placeholder (it makes</span><br>    <span class="hljs-comment">// no sense, because get_bit only returns</span><br>    <span class="hljs-comment">// 0 or 1)</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>&amp;(x&gt;&gt;n));<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>(x &gt;&gt; n)</code>：首先，将整数 <code>x</code> 向右移动 <code>n</code> 位，以便将第 <code>n</code> 位移到最低位，这样我们可以轻松地从最低位提取出这个位的值。</li><li><code>(1 &amp; (x &gt;&gt; n))</code>：然后，将移位后的结果与二进制数 <code>0b00000001</code>（即1）进行按位与操作。这将保留右移后的结果的最低位，也就是第 <code>n</code> 位。</li><li><code>return (1 &amp; (x &gt;&gt; n));</code>：最后，将上述按位与操作的结果作为函数的返回值，即返回第 <code>n</code> 位的值（0 或 1）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">set_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> * x,</span><br><span class="hljs-params">             <span class="hljs-type">unsigned</span> n,</span><br><span class="hljs-params">             <span class="hljs-type">unsigned</span> v)</span> &#123;<br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    <span class="hljs-type">unsigned</span> mask = ~(<span class="hljs-number">1</span>&lt;&lt;n);<br>    (*x) = ((*x) &amp; mask)|(v &lt;&lt; n);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>unsigned mask = ~(1&lt;&lt;n);</code>：首先，创建一个掩码 <code>mask</code>，它的目的是将第 <code>n</code> 位设置为0，其他位都保持不变。这是通过将数字1左移 <code>n</code> 位然后取反得到的，实际上就是将第 <code>n</code> 位设置为0，其他位都设置为1。</li><li><code>(*x) = ((*x) &amp; mask)|(v &lt;&lt; n);</code>：然后，使用掩码和左移操作将指定的位设置为新的值 <code>v</code>。<ul><li><code>(*x) &amp; mask</code>：这个步骤将保留 <code>x</code> 中除第 <code>n</code> 位以外的所有位，通过将 <code>x</code> 和掩码 <code>mask</code> 进行按位与操作。</li><li><code>v &lt;&lt; n</code>：将值 <code>v</code> 左移 <code>n</code> 位，将要设置的位放置在正确的位置。</li><li><code>((*x) &amp; mask) | (v &lt;&lt; n)</code>：将上述两个步骤的结果进行按位或操作，将保留的部分与设置的位合并，得到最终的结果。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">flip_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> * x,</span><br><span class="hljs-params">              <span class="hljs-type">unsigned</span> n)</span> &#123;<br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    (*x)^=(<span class="hljs-number">1</span>&lt;&lt;n);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>(1 &lt;&lt; n)</code>：首先，将数字1左移 <code>n</code> 位，生成一个只有第 <code>n</code> 位为1，其他位为0的数。例如，如果 <code>n</code> 是3，则 <code>1 &lt;&lt; 3</code> 的结果是二进制数 <code>0b00001000</code>。</li><li><code>(*x) ^= (1 &lt;&lt; n);</code>：然后，将左移后的结果与原始值 <code>x</code> 进行按位异或操作（<code>^=</code> 表示按位异或赋值操作）。按位异或操作的性质是，对于两个操作数的每一位，如果两个操作数的对应位不同，则结果的该位为1，否则为0。因此，这个操作将会翻转 <code>x</code> 的第 <code>n</code> 位。</li></ol><h2 id="Exercise-2-Linear-Feedback-Shift-Register"><a href="#Exercise-2-Linear-Feedback-Shift-Register" class="headerlink" title="Exercise 2: Linear Feedback Shift Register"></a>Exercise 2: Linear Feedback Shift Register</h2><p>很简单的一个东西，由于makefile 设置的原因，不要调用<code>bit_ops.c</code>的函数在<code>lfsr.c</code>中</p><p><a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">lfsr</a>倒是蛮有意思</p><h2 id="Exercise-3-Memory-Management"><a href="#Exercise-3-Memory-Management" class="headerlink" title="Exercise 3: Memory Management"></a>Exercise 3: Memory Management</h2><p>最开始没想明白两个函数为什么有问题，只是觉得跟之前写的不一样，因为之前结构也要malloc分配空间。</p><p>贴上chatgpt的解释</p><h3 id="bad-vector-new"><a href="#bad-vector-new" class="headerlink" title="bad_vector_new()"></a><em>bad_vector_new()</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Bad example of how to create a new vector */</span><br><span class="hljs-type">vector_t</span> *<span class="hljs-title function_">bad_vector_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* Create the vector and a pointer to it */</span><br>    <span class="hljs-type">vector_t</span> *retval, v;<br>    retval = &amp;v;<br><br>    <span class="hljs-comment">/* Initialize attributes */</span><br>    retval-&gt;size = <span class="hljs-number">1</span>;<br>    retval-&gt;data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (retval-&gt;data == <span class="hljs-literal">NULL</span>) &#123;<br>        allocation_failed();<br>    &#125;<br><br>    retval-&gt;data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>它试图返回一个指向局部变量的指针，这会导致悬空指针问题，而且在修改局部变量的成员时也会导致未定义行为。</p><p>具体来说，这段代码的问题在于：</p><ol><li><code>vector_t v;</code>：在<strong>堆栈</strong>上创建了一个局部变量 <code>v</code>，它的生命周期仅限于 <code>bad_vector_new()</code> 函数的执行期间。</li><li><code>retval = &amp;v;</code>：将局部变量 <code>v</code> 的地址赋给了 <code>retval</code>，使得 <code>retval</code> 指向了局部变量 <code>v</code> 所在的内存地址。</li><li><code>retval-&gt;size = 1;</code> 和 <code>retval-&gt;data = malloc(sizeof(int));</code>：试图在局部变量 <code>v</code> 上操作，但由于它是在堆栈上分配的，这会导致未定义行为。这意味着你正在修改一个局部变量的成员，而不是动态分配的内存。</li><li><code>return retval;</code>：返回了指向局部变量 <code>v</code> 的指针 <code>retval</code>。</li></ol><p>这会导致类似前面提到的问题，当函数 <code>bad_vector_new()</code> 结束时，局部变量 <code>v</code> 将被销毁，但是 <code>retval</code> 仍然指向了该内存地址，从而导致悬空指针。同时，试图在局部变量上进行成员访问也会导致未定义行为。</p><h3 id="also-bad-vector-new"><a href="#also-bad-vector-new" class="headerlink" title="also_bad_vector_new()"></a><em>also_bad_vector_new()</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Another suboptimal way of creating a vector */</span><br><span class="hljs-type">vector_t</span> <span class="hljs-title function_">also_bad_vector_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* Create the vector */</span><br>    <span class="hljs-type">vector_t</span> v;<br><br>    <span class="hljs-comment">/* Initialize attributes */</span><br>    v.size = <span class="hljs-number">1</span>;<br>    v.data = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (v.data == <span class="hljs-literal">NULL</span>) &#123;<br>        allocation_failed();<br>    &#125;<br>    v.data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>它试图返回一个局部变量 <code>v</code>，它在函数结束时将会被销毁，导致悬空指针问题。</p><p>具体问题如下：</p><ol><li><code>vector_t v;</code>：在堆栈上创建了一个局部变量 <code>v</code>，它的生命周期仅限于 <code>also_bad_vector_new()</code> 函数的执行期间。</li><li><code>v.size = 1;</code> 和 <code>v.data = malloc(sizeof(int));</code>：在局部变量 <code>v</code> 上操作，分配了内存并将指针存储在 <code>v.data</code> 中。由于 <code>v</code> 是在堆栈上分配的，当函数 <code>also_bad_vector_new()</code> 结束时，局部变量 <code>v</code> 将被销毁，导致 <code>v.data</code> 指向的内存变成了悬空指针。</li><li><code>return v;</code>：试图返回局部变量 <code>v</code>。</li></ol><p>这会导致悬空指针问题，因为在函数结束后，局部变量 <code>v</code> 将被销毁，但是返回的 <code>v</code> 中的指针 <code>v.data</code> 仍然指向了之前分配的内存地址</p><div class="note note-info">            <p>综上，就是malloc这个应该在heap上调用的函数，不应用到stack上，导致的一系列问题</p>          </div><h3 id="vector-new"><a href="#vector-new" class="headerlink" title="vector_new()"></a><em>vector_new()</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">vector_t</span> *<span class="hljs-title function_">vector_new</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/* Declare what this function will return */</span><br>    <span class="hljs-type">vector_t</span> *retval;<br><br>    <span class="hljs-comment">/* First, we need to allocate memory on the heap for the struct */</span><br>    retval = (<span class="hljs-type">vector_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">vector_t</span>));<br>  <br><br>    <span class="hljs-comment">/* Check our return value to make sure we got memory */</span><br>    <span class="hljs-keyword">if</span> (retval == <span class="hljs-literal">NULL</span>) &#123;<br>        allocation_failed();<br>    &#125;<br><br>    <span class="hljs-comment">/* Now we need to initialize our data.</span><br><span class="hljs-comment">       Since retval-&gt;data should be able to dynamically grow,</span><br><span class="hljs-comment">       what do you need to do? */</span><br>    retval-&gt;size = <span class="hljs-number">1</span><span class="hljs-comment">/* YOUR CODE HERE */</span>;<br>    retval-&gt;data = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">/* YOUR CODE HERE */</span>;<br><br>    <span class="hljs-comment">/* Check the data attribute of our vector to make sure we got memory */</span><br>    <span class="hljs-keyword">if</span> (retval-&gt;data == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">free</span>(retval);<span class="hljs-comment">//Why is this line necessary?</span><br>        allocation_failed();<br>    &#125;<br><br>    <span class="hljs-comment">/* Complete the initialization by setting the single component to zero */</span><br>    <span class="hljs-comment">/* YOUR CODE HERE */</span> <br>    retval-&gt;data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* and return... */</span><br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p>正常思路，给struct 手动分配内存就好</p><h3 id="vector-set"><a href="#vector-set" class="headerlink" title="vector_set()"></a><em>vector_set()</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vector_set</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-comment">/* What do you need to do if the location is greater than the size we have</span><br><span class="hljs-comment">     * allocated?  Remember that unset locations should contain a value of 0.</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* YOUR SOLUTION HERE */</span><br>    <span class="hljs-keyword">if</span>(loc &gt;= v-&gt;size)&#123;<br>        <span class="hljs-type">size_t</span> new_size = loc + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>* new_data = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">realloc</span>(v-&gt;data,new_size*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span>(new_data == <span class="hljs-literal">NULL</span>)&#123;<br>            allocation_failed();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = v-&gt;size ; i &lt; new_size; i++)&#123;<br><br>            v-&gt;data[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        v-&gt;size = new_size;<br>        v-&gt;data = new_data;<br>    &#125;<br>    v-&gt;data[loc] = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意设0时，别覆盖了之前设置过值就好</p><h3 id="makefile-test"><a href="#makefile-test" class="headerlink" title="makefile test"></a>makefile test</h3><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">Calling vector_new()<br>Calling vector_delete()<br>vector_new() again<br>These should all return 0 (vector_get()): 0 0 0<br>Doing a bunch of vector_set()s<br>These should be equal:<br>98 = 98<br>15 = 15<br>65 = 65<br>-123 = -123<br>21 = 21<br>43 = 43<br>0 = 0<br>0 = 0<br>0 = 0<br>3 = 3<br>Test complete.<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><em>在 makefile 中为</em> <code>vector-test</code> <em>目标实施规则。</em><img src="/2023/08/10/cs61c-lab02/vector_set1.png" class=""></li><li><em>在 vector.h 中添加函数声明</em><img src="/2023/08/10/cs61c-lab02/vector_set2.png" class=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-lec</title>
    <link href="/2023/08/09/cs61c-lec/"/>
    <url>/2023/08/09/cs61c-lec/</url>
    
    <content type="html"><![CDATA[<h1 id="Lec06-Floating-Point"><a href="#Lec06-Floating-Point" class="headerlink" title="Lec06 Floating Point"></a>Lec06 Floating Point</h1><h2 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h2>  <img src="/2023/08/09/cs61c-lec/Normalformat.jpg" class="" title="examplename"><h2 id="overflow-underflow"><a href="#overflow-underflow" class="headerlink" title="overflow - underflow"></a>overflow - underflow</h2>  <img src="/2023/08/09/cs61c-lec/Overflow.png" class="" title="examplename"><h2 id="浮点数standard-sign-exponent-significand"><a href="#浮点数standard-sign-exponent-significand" class="headerlink" title="浮点数standard - sign exponent significand"></a>浮点数standard - sign exponent significand</h2>  <h2 id="IEEE-754-使用-“biased-exponent”-表示-原因（P-H-p136"><a href="#IEEE-754-使用-“biased-exponent”-表示-原因（P-H-p136" class="headerlink" title="IEEE 754 使用 “biased exponent” 表示 + 原因（P&amp;H p136)"></a>IEEE 754 使用 “biased exponent” 表示 + 原因（P&amp;H p136)</h2>  <img src="/2023/08/09/cs61c-lec/biasednotation.png" class="" title="examplename"><h2 id="浮点数实际表示值（使用biased-notation后）"><a href="#浮点数实际表示值（使用biased-notation后）" class="headerlink" title="浮点数实际表示值（使用biased notation后）"></a>浮点数实际表示值（使用biased notation后）</h2><p>（-1)^S x (1+Significand) x 2^(Exponent-127)</p><h2 id="FP-表示0；infinity；NaN-Not-a-Number"><a href="#FP-表示0；infinity；NaN-Not-a-Number" class="headerlink" title="FP 表示0；infinity；NaN(Not a Number)"></a>FP 表示0；<code>infinity</code>；<code>NaN</code>(Not a Number)</h2><ul><li>(<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/pdfs/lectures/lec06.pdf">sild lec06</a> p19-p23)</li></ul><h2 id="FP-表示Denorms-非规格化数-重要理解"><a href="#FP-表示Denorms-非规格化数-重要理解" class="headerlink" title="FP 表示Denorms(非规格化数) 重要理解"></a>FP 表示<code>Denorms</code>(非规格化数) 重要理解</h2><p><a href="https://youtu.be/Gs0ARZzY-gM?list=PLnvUoC1Ghb7zz9gZ7A6DHo_YI7m_QtTwo&t=456">https://youtu.be/Gs0ARZzY-gM?list=PLnvUoC1Ghb7zz9gZ7A6DHo_YI7m_QtTwo&amp;t=456</a><br>  <img src="/2023/08/09/cs61c-lec/Denorms.png" class="" title="Denorms"></p><ul><li>表示 1&#x2F;3</li><li>FP 加法不可交换</li><li>FP Precision &amp; Accuracy</li></ul><h2 id="舍入操作-（P-H-3-5-7"><a href="#舍入操作-（P-H-3-5-7" class="headerlink" title="舍入操作 （P &amp; H 3.5.7)"></a>舍入操作 （P &amp; H 3.5.7)</h2>  <img src="/2023/08/09/cs61c-lec/round.png" class="" title="examplename"><h2 id="由于浮点数的significand-每次加一后，对整个浮点数其实加1-2-exponent-127-，所以它会跳过某些数"><a href="#由于浮点数的significand-每次加一后，对整个浮点数其实加1-2-exponent-127-，所以它会跳过某些数" class="headerlink" title="由于浮点数的significand 每次加一后，对整个浮点数其实加1*2^(exponent+127)，所以它会跳过某些数"></a>由于浮点数的significand 每次加一后，对整个浮点数其实加1*2^(exponent+127)，所以它会跳过某些数</h2><ul><li><p>因此，无法精确表示且将舍入的第一个整数是：<br>对于<code>float</code>而言，16,777,217（224 + 1）。<br>对于<code>double</code>而言，9,007,199,254,740,993（253 + 1 ）。</p><img src="/2023/08/09/cs61c-lec/simulator.png" class="" title="examplename"></li><li><p><a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">IEEE 754 simulator</a></p></li></ul><h1 id="Lec07-RISC-V-Intro"><a href="#Lec07-RISC-V-Intro" class="headerlink" title="Lec07 RISC-V Intro"></a>Lec07 RISC-V Intro</h1><h2 id="Risc-V-抽象层"><a href="#Risc-V-抽象层" class="headerlink" title="Risc-V 抽象层"></a>Risc-V 抽象层</h2>  <img src="/2023/08/09/cs61c-lec/abstraction.png" class="" title="examplename"><h2 id="Risc-v-ISA-Instrument-Set-Architecture"><a href="#Risc-v-ISA-Instrument-Set-Architecture" class="headerlink" title="Risc-v -&gt; ISA(Instrument Set Architecture)"></a>Risc-v -&gt; ISA(<em>Instrument Set Architecture</em>)</h2>  <img src="/2023/08/09/cs61c-lec/assembly.png" class="FP" title="examplename"><ul><li><p>寄存器(register)</p></li><li><p>基础操作符 - add sub addi</p></li></ul><h1 id="Lec08-RISC-V-lw-sw-Decisions-I"><a href="#Lec08-RISC-V-lw-sw-Decisions-I" class="headerlink" title="Lec08 RISC-V lw, sw, Decisions I"></a>Lec08 RISC-V lw, sw, Decisions I</h1><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>  1个字32个位，即4个字节；一个字节8个位。<br>  <img src="/2023/08/09/cs61c-lec/Address.png" class="" title="examplename"></p><h2 id="小尾数法-Little-Endian-内存存储字节"><a href="#小尾数法-Little-Endian-内存存储字节" class="headerlink" title="小尾数法(Little Endian) 内存存储字节"></a>小尾数法(Little Endian) 内存存储字节</h2>  <img src="/2023/08/09/cs61c-lec/littleendian.png" class="" title="examplename"><h2 id="从寄存器访问比从内存访问快"><a href="#从寄存器访问比从内存访问快" class="headerlink" title="从寄存器访问比从内存访问快"></a>从寄存器访问比从内存访问快</h2>  <img src="/2023/08/09/cs61c-lec/register-memory.png" class="" title="examplename"><h2 id="lw-Load-from-Memory-to-Register-一个字32位"><a href="#lw-Load-from-Memory-to-Register-一个字32位" class="headerlink" title="lw Load from Memory to Register (一个字32位)"></a><code>lw</code> Load from Memory to Register (一个字32位)</h2>  <img src="/2023/08/09/cs61c-lec/lw.png" class="" title="examplename"><h2 id="sw-Store-from-Register-to-Memory-一个字32位"><a href="#sw-Store-from-Register-to-Memory-一个字32位" class="headerlink" title="sw Store from Register to Memory (一个字32位)"></a><code>sw</code> Store from Register to Memory (一个字32位)</h2>  <img src="/2023/08/09/cs61c-lec/sw.png" class="" title="examplename"><h2 id="加载存储字节-加载8位而不是32位，存储到寄存器中时需要sign-extend"><a href="#加载存储字节-加载8位而不是32位，存储到寄存器中时需要sign-extend" class="headerlink" title="加载存储字节, 加载8位而不是32位，存储到寄存器中时需要sign-extend"></a>加载存储字节, 加载8位而不是32位，存储到寄存器中时需要<code>sign-extend</code></h2>  <img src="/2023/08/09/cs61c-lec/lwbytes.png" class="" title="examplename">  <img src="/2023/08/09/cs61c-lec/example01.png" class="" title="examplename"><h2 id="保留addi-的原因"><a href="#保留addi-的原因" class="headerlink" title="保留addi 的原因"></a>保留addi 的原因</h2>  <img src="/2023/08/09/cs61c-lec/save_addi.png" class="" title="examplename"><ul><li>beq; bne; blt; bge</li><li>j(jump) label</li></ul><h2 id="if-else-语法"><a href="#if-else-语法" class="headerlink" title="if-else 语法"></a>if-else 语法</h2>  <img src="/2023/08/09/cs61c-lec/if-example.png" class="" title="examplename"><h2 id="for-loop-语法"><a href="#for-loop-语法" class="headerlink" title="for-loop 语法"></a>for-loop 语法</h2>  <img src="/2023/08/09/cs61c-lec/for-loop.png" class="" title="examplename"><h1 id="Lec09-RISC-V-Decisions-II"><a href="#Lec09-RISC-V-Decisions-II" class="headerlink" title="Lec09 RISC-V Decisions II"></a>Lec09 RISC-V Decisions II</h1><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2>  <img src="/2023/08/09/cs61c-lec/logicoperations.png" class="" title="examplename"><h2 id="immediate-版"><a href="#immediate-版" class="headerlink" title="immediate 版"></a>immediate 版</h2>  <img src="/2023/08/09/cs61c-lec/andi.png" class="" title="examplename"><h2 id="掩码（mask）"><a href="#掩码（mask）" class="headerlink" title="掩码（mask）"></a>掩码（mask）</h2>  <img src="/2023/08/09/cs61c-lec/mask.png" class="" title="examplename"><h2 id="使用Xor-with-11111111-2-替代-not"><a href="#使用Xor-with-11111111-2-替代-not" class="headerlink" title="使用Xor with 11111111_2 替代 not"></a>使用<code>Xor with 11111111_2</code> 替代 <code>not</code></h2><h2 id="逻辑左移-sll-slli"><a href="#逻辑左移-sll-slli" class="headerlink" title="逻辑左移 sll &amp; slli"></a>逻辑左移 <code>sll &amp; slli</code></h2>   <img src="/2023/08/09/cs61c-lec/leftshift.png" class="" title="examplename"><h2 id="逻辑右移sra-srai"><a href="#逻辑右移sra-srai" class="headerlink" title="逻辑右移sra &amp; srai"></a>逻辑右移<code>sra &amp; srai</code></h2>   <img src="/2023/08/09/cs61c-lec/rightshift.png" class="" title="examplename"><h2 id="Assembly-编译"><a href="#Assembly-编译" class="headerlink" title="Assembly 编译"></a>Assembly 编译</h2>   <img src="/2023/08/09/cs61c-lec/process.png" class="" title="examplename"><h2 id="程序存储在memory中，一个指令4个字节"><a href="#程序存储在memory中，一个指令4个字节" class="headerlink" title="程序存储在memory中，一个指令4个字节"></a>程序存储在memory中，一个指令4个字节</h2>   <img src="/2023/08/09/cs61c-lec/programstore.png" class="" title="examplename"><h2 id="PC-program-counter-存储下一条指令的内存地址，从内存中抓取指令，然后control使用Datapath和memory执行，更新PC"><a href="#PC-program-counter-存储下一条指令的内存地址，从内存中抓取指令，然后control使用Datapath和memory执行，更新PC" class="headerlink" title="PC(program counter)存储下一条指令的内存地址，从内存中抓取指令，然后control使用Datapath和memory执行，更新PC"></a>PC(program counter)存储下一条指令的内存地址，从内存中抓取指令，然后<code>control</code>使用<code>Datapath</code>和<code>memory</code>执行，更新PC</h2>   <img src="/2023/08/09/cs61c-lec/programexecution.png" class="" title="examplename"><h2 id="pseudoinstructions-mv-li-nop"><a href="#pseudoinstructions-mv-li-nop" class="headerlink" title="pseudoinstructions: mv , li &amp; nop"></a>pseudoinstructions: mv , li &amp; nop</h2>   <img src="/2023/08/09/cs61c-lec/mv.png" class="" title="examplename"><h2 id="function-call-jal-j-and-l-jalr-jr"><a href="#function-call-jal-j-and-l-jalr-jr" class="headerlink" title="function call - jal(j and l) jalr(jr)"></a>function call - jal(j and l) jalr(jr)</h2>   <img src="/2023/08/09/cs61c-lec/pr.png" class="" title="examplename">   <img src="/2023/08/09/cs61c-lec/fc1.png" class="" title="examplename">   <img src="/2023/08/09/cs61c-lec/fc2.png" class="" title="examplename">   <img src="/2023/08/09/cs61c-lec/fc3.png" class="" title="examplename">   <img src="/2023/08/09/cs61c-lec/fc4.png" class="" title="examplename"><h2 id="jal-jalr"><a href="#jal-jalr" class="headerlink" title="jal &amp; jalr"></a>jal &amp; jalr</h2>   <img src="/2023/08/09/cs61c-lec/jaljalr.png" class="" title="examplename"><h2 id="pseudoinstructions-j-jr-ret"><a href="#pseudoinstructions-j-jr-ret" class="headerlink" title="pseudoinstructions : j, jr &amp; ret"></a>pseudoinstructions : j, jr &amp; ret</h2>   <img src="/2023/08/09/cs61c-lec/jjrret-pserdoinstruments.png" class="" title="examplename"><h1 id="Lec10-RISC-V-Procedures"><a href="#Lec10-RISC-V-Procedures" class="headerlink" title="Lec10 RISC-V Procedures"></a>Lec10 RISC-V Procedures</h1><p>主要讲stack，嵌套函数调用，寄存器</p><h2 id="32-个寄存器的用处，symbolic-name"><a href="#32-个寄存器的用处，symbolic-name" class="headerlink" title="32 个寄存器的用处，symbolic name"></a>32 个寄存器的用处，symbolic name</h2>  <img src="/2023/08/09/cs61c-lec/symbolicRegisterName.png" class="" title="examplename"><h2 id="当需要多余的寄存器时，我们讲旧的冲突的寄存器值存储与stack中"><a href="#当需要多余的寄存器时，我们讲旧的冲突的寄存器值存储与stack中" class="headerlink" title="当需要多余的寄存器时，我们讲旧的冲突的寄存器值存储与stack中"></a>当需要多余的寄存器时，我们讲旧的冲突的寄存器值存储与stack中</h2><h2 id="sp-stack-pointer，sp自上而下增长-sp-always-points-to-the-last-used-space-in-the-stack"><a href="#sp-stack-pointer，sp自上而下增长-sp-always-points-to-the-last-used-space-in-the-stack" class="headerlink" title="sp -&gt; stack pointer，sp自上而下增长 - sp always points to the last used space in the stack"></a>sp -&gt; stack pointer，sp自上而下增长 - sp always points to the last used space in the stack</h2>  <img src="/2023/08/09/cs61c-lec/sp.png" class="" title="examplename">  <img src="/2023/08/09/cs61c-lec/sp2.png" class="" title="examplename"><h2 id="leaf类型函数调用"><a href="#leaf类型函数调用" class="headerlink" title="leaf类型函数调用"></a>leaf类型函数调用</h2>  <img src="/2023/08/09/cs61c-lec/leaf-unested.png" class="" title="examplename"><p>  assembly<br>  <img src="/2023/08/09/cs61c-lec/leaf-assembly.png" class="" title="examplename"><br>  保存了s0,s1 的stack<br>  <img src="/2023/08/09/cs61c-lec/stack-saves0s1.png" class="" title="examplename"></p><h2 id="嵌套函数调用，"><a href="#嵌套函数调用，" class="headerlink" title="嵌套函数调用，"></a>嵌套函数调用，</h2><p>callee(被调用程序) 会破坏 caller(调用程序)的register值，例如所有的函数返回地址(ra)都存储在x1中，callee的ra会与caller的ra冲突；或者是两个函数各自的参数，这些我们都需要存储register值在stack中<br>  <img src="/2023/08/09/cs61c-lec/callerfunc.png" class="" title="examplename"><br>  为了避免存储所有的register，造成巨大的负担，caller需要知道那些register的值，一定会被callee恢复，那些register的值不会被callee确保恢复。<br>  <img src="/2023/08/09/cs61c-lec/preserv-notpreserv.png" class="" title="examplename"><br>  &amp;n</p>  <img src="/2023/08/09/cs61c-lec/preserv-notpreserv2.png" class="" title="examplename">  <p>  &amp;n</p>  <img src="/2023/08/09/cs61c-lec/preservitems.png" class="" title="examplename"><ul><li><p>c中的automatic &amp; static 变量存储</p></li><li><p>对不适合寄存器存储的自动变量(automatic or local variables)使用stack</p></li></ul><h2 id="过程帧-活动变量-Procedure-frame-or-activation-record-stack中存储寄存器和自动变量的部分"><a href="#过程帧-活动变量-Procedure-frame-or-activation-record-stack中存储寄存器和自动变量的部分" class="headerlink" title="过程帧 活动变量 - Procedure frame or activation record  stack中存储寄存器和自动变量的部分"></a><strong>过程帧</strong> <strong>活动变量</strong> - Procedure frame or activation record  stack中存储寄存器和自动变量的部分</h2>  <img src="/2023/08/09/cs61c-lec/stack01.png" class="" title="examplename"><h2 id="使用stack的例子"><a href="#使用stack的例子" class="headerlink" title="使用stack的例子"></a>使用stack的例子</h2>  <img src="/2023/08/09/cs61c-lec/func-use-stack.png" class="" title="examplename"><h2 id="执行程序时，static，stack，heap在memory中"><a href="#执行程序时，static，stack，heap在memory中" class="headerlink" title="执行程序时，static，stack，heap在memory中"></a>执行程序时，static，stack，heap在memory中</h2>  <img src="/2023/08/09/cs61c-lec/Memory-allocation.png" class="png" title="examplename"> <p>  &amp;n<br>  <img src="/2023/08/09/cs61c-lec/Memory01.png" class="png" title="examplename">   </p><p>  &amp;n<br>  <img src="/2023/08/09/cs61c-lec/Memory02.png" class="png" title="examplename">  </p><p>  &amp;n<br>  <img src="/2023/08/09/cs61c-lec/heap.png" class="png" title="examplename">  </p><h2 id="Risc-v-32-的-以学指令"><a href="#Risc-v-32-的-以学指令" class="headerlink" title="Risc-v 32 的 以学指令"></a>Risc-v 32 的 以学指令</h2>  <img src="/2023/08/09/cs61c-lec/RV32sofar.png" class="png" title="examplename"><h1 id="Lec11-RISC-V-Instruction-Formats-I"><a href="#Lec11-RISC-V-Instruction-Formats-I" class="headerlink" title="Lec11 RISC-V Instruction Formats I"></a>Lec11 RISC-V Instruction Formats I</h1><p>从本节课开始学习机器语言程序  </p><img src="/2023/08/09/cs61c-lec/architecture.png" class="png" title="examplename"><h2 id="六种指令形式"><a href="#六种指令形式" class="headerlink" title="六种指令形式"></a>六种指令形式</h2><img src="/2023/08/09/cs61c-lec/sixformats.png" class="png" title="examplename"><h2 id="将32位的指令分为几个fields"><a href="#将32位的指令分为几个fields" class="headerlink" title="将32位的指令分为几个fields"></a>将32位的指令分为几个fields</h2><img src="/2023/08/09/cs61c-lec/fields.png" class="png" title="examplename"><ul><li><p>32个寄存器正好用五位二进编码</p></li><li><p>32位指令可以用8位16进制数表示</p></li></ul><h2 id="R-Format-指令"><a href="#R-Format-指令" class="headerlink" title="R-Format 指令"></a>R-Format 指令</h2><img src="/2023/08/09/cs61c-lec/addexample.png" class="png" title="examplename"><p><strong>R-Format instructions</strong></p><img src="/2023/08/09/cs61c-lec/Rformat-instructions.png" class="png" title="examplename"><h2 id="I-Format-指令"><a href="#I-Format-指令" class="headerlink" title="I-Format 指令"></a>I-Format 指令</h2><ul><li>指令中的immediates，必然要在32位中表示出来，否则也无法直接使用</li></ul><img src="/2023/08/09/cs61c-lec/I-format-fields.png" class="png" title="examplename"><ul><li>由于immediates 11位，为了跟32位进行运算，所以默认sign-extension在进行运算之前</li></ul><img src="/2023/08/09/cs61c-lec/addiexample.png" class="png" title="examplename"><p><strong>I-Format instructions</strong></p><img src="/2023/08/09/cs61c-lec/I-Format-instructions.png" class="png" title="examplename"><p>shamt 是移位的位数</p><h2 id="I-Format-Load-指令"><a href="#I-Format-Load-指令" class="headerlink" title="I-Format Load 指令"></a>I-Format Load 指令</h2><img src="/2023/08/09/cs61c-lec/load-fields.png" class="png" title="examplename"><p>&amp;n</p><p><strong>Load-instructions</strong></p><img src="/2023/08/09/cs61c-lec/load-instructions.png" class="png" title="examplename"><ul><li><code>lh</code> load halfword 加载16个字节，sign-extention后，存储到32 的register中</li></ul><h2 id="S-Format-指令"><a href="#S-Format-指令" class="headerlink" title="S-Format 指令"></a>S-Format 指令</h2><img src="/2023/08/09/cs61c-lec/S-Format-fields.png" class="png" title="examplename"><ul><li>存储时需要的偏移值(immediates)被分割，为了使<code>rs1/rs2</code>跟其他类型的指令在同一位置<ul><li>Register names more critical than immediate bits in hardware design</li></ul></li></ul><img src="/2023/08/09/cs61c-lec/swexample.png" class="png" title="examplename"><p><strong>S-Format instructions</strong></p><img src="/2023/08/09/cs61c-lec/S-Format-instructions.png" class="png" title="examplename"><h1 id="Lec12-RISC-V-Instruction-Formats-II"><a href="#Lec12-RISC-V-Instruction-Formats-II" class="headerlink" title="Lec12 RISC-V Instruction Formats II"></a>Lec12 RISC-V Instruction Formats II</h1><h2 id="B-Format-指令"><a href="#B-Format-指令" class="headerlink" title="B-Format 指令"></a>B-Format 指令</h2><ul><li>分支指令，主要用来跳转到label，接下来先介绍如何对label进行编码<ul><li>branch指令通常用于(if-else,while,for-loop)，一般较短，相比下函数调用和无条件跳转label位置较远会使用jump 指令</li><li>由于pc(program counter)会保存当前位置的地址，所以我们采用<code>PC-Relative Addressing</code> (pc相对寻址)来确认branch的label的地址</li></ul></li></ul><img src="/2023/08/09/cs61c-lec/PC-Relative-Addressing.png" class="png" title="examplename"><ul><li>能跳转到pc相对<code>2^11*32bits</code>前后的指令，由于branch一般不大，是能满足使用需求的</li></ul><img src="/2023/08/09/cs61c-lec/branchcalcu.png" class="png" title="examplename"><ul><li>一般pc应该加<code>immediate * 4</code>不过risc-v为了满足它支持的16位指令，所以加的是<code>immediate * 2</code></li></ul><p><strong>B-Format fields</strong></p><img src="/2023/08/09/cs61c-lec/B-Format-fields.png" class="png" title="examplename"><ul><li>由于跳转的相对地址(immediates)一定是偶数（如果是奇数，就会跳转到16位或是32位指令的中间，而不是头部），最后一位数一定是0，所以默认不保存</li></ul><p><strong>Branch example</strong></p><ul><li>计算偏差</li></ul><img src="/2023/08/09/cs61c-lec/Branchexample.png" class="png" title="examplename"><ul><li>完成编码</li></ul><img src="/2023/08/09/cs61c-lec/Branchexample1.png" class="png" title="examplename"><p><strong>B-Format-instructions</strong></p><img src="/2023/08/09/cs61c-lec/B-Format-instructions.png" class="png" title="examplename"><div class="note note-info">            <p>注意，由于branch中的跳转offset是计算出来固定的，如果你修改代码中单个某行的位置，offset就会错误；如果移动整个代码文件，由于offset是相对的，相对位置没有变化，offset仍是正确的。就是你导入这个文件branch不会出错，修改branch相关代码位置就会出错。</p>          </div><h2 id="I型编码后immediates值具体存储"><a href="#I型编码后immediates值具体存储" class="headerlink" title="I型编码后immediates值具体存储"></a>I型编码后immediates值具体存储</h2><img src="/2023/08/09/cs61c-lec/immediatecoding.png" class="png" title="examplename"><h2 id="如果branch-的offset-过大"><a href="#如果branch-的offset-过大" class="headerlink" title="如果branch 的offset 过大"></a>如果branch 的offset 过大</h2><img src="/2023/08/09/cs61c-lec/bigoffset.png" class="png" title="examplename"><h2 id="U-Format-for-“Upper-Immediate”-Instructions"><a href="#U-Format-for-“Upper-Immediate”-Instructions" class="headerlink" title="U-Format for “Upper Immediate” Instructions"></a>U-Format for “Upper Immediate” Instructions</h2><ul><li>存储较大的immediate，能存储20位（用于存储32位中高的20位）</li></ul><img src="/2023/08/09/cs61c-lec/U-Format-fields.png" class="png" title="examplename"><ul><li>主要用于<code>lui</code> &amp; <code>auipc</code>两个指令</li></ul><p><strong>LUI</strong> 创建32位immediate -&gt; 伪指令<code>li</code></p><img src="/2023/08/09/cs61c-lec/LUI.png" class="png" title="examplename"><ul><li>由于addi sign-extension 的缘故，后12位符号扩展后，两个数相加，中间的位值会小1</li></ul><img src="/2023/08/09/cs61c-lec/LUI1.png" class="png" title="examplename"><ul><li>汇编器会自行处理这个问题 -&gt; 给20位最后一位加一，我们直接使用pseudo instruction <code>li</code>即可得到正确的数值</li></ul><img src="/2023/08/09/cs61c-lec/LUI2.png" class="png" title="examplename"><p><strong>AUIPC</strong></p><img src="/2023/08/09/cs61c-lec/AUIPC.png" class="png" title="examplename"><h2 id="J-Format-jal"><a href="#J-Format-jal" class="headerlink" title="J-Format(jal)"></a>J-Format(jal)</h2><ul><li>顾名思义，用于jump 指令，也只有一个jump指令</li></ul><ul><li>在<code>rd</code>中保存<code>pc+4</code></li><li>设置<code>pc = pc + offset</code></li><li>前后<code>218 32-bit instructions</code></li></ul><p><strong>JAL用处</strong></p><img src="/2023/08/09/cs61c-lec/usesofjal.png" class="png" title="examplename"><h2 id="JALR-Instruction-I-Format"><a href="#JALR-Instruction-I-Format" class="headerlink" title="JALR Instruction (I-Format)"></a>JALR Instruction (I-Format)</h2><ul><li>注意 I-Format</li></ul><img src="/2023/08/09/cs61c-lec/jalr-fields.png" class="png" title="examplename"><ul><li>直接加值，不乘2</li><li>一般用于跳转到绝对地址</li></ul><img src="/2023/08/09/cs61c-lec/usesofjalr.png" class="png" title="examplename"><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><img src="/2023/08/09/cs61c-lec/summaryofsixformat.png" class="png" title="examplename">]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-proj1</title>
    <link href="/2023/08/05/cs61c-proj1/"/>
    <url>/2023/08/05/cs61c-proj1/</url>
    
    <content type="html"><![CDATA[<h1 id="Project-1-Conway’s-Game-of-Life-in-RGB"><a href="#Project-1-Conway’s-Game-of-Life-in-RGB" class="headerlink" title="Project 1: Conway’s Game of Life, in RGB!"></a>Project 1: Conway’s Game of Life, in RGB!</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) proj1 笔记</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-proj">https://github.com/2333monster/my-cs61c-proj</a></p></blockquote><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><img src="https://inst.eecs.berkeley.edu/~cs61c/fa20/projects/proj1/conway.gif" alt="img" style="zoom: 25%;" /><p>实现Game of LIfe.</p><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>原仓库设置为只读，我下载了源码解压</p><h3 id="PPM-Format"><a href="#PPM-Format" class="headerlink" title="PPM Format"></a>PPM Format</h3><p>PPM是一种存储图片的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PLaintext">P3<br>4 5<br>255<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>255 255 255   255 255 255   255 255 255     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br>  0   0   0     0   0   0     0   0   0     0   0   0<br><br></code></pre></td></tr></table></figure><p>头部第一行 P3 -&gt; 这是一个P3格式的PPM 文件（还有5种格式）</p><p>头部第二行 4 5 -&gt; 图片 4 pixels 宽 5 pixels 高 </p><p>头部第三行 255 -&gt; 描述颜色值的范围 0~255</p><p>文件的余下部分是图片的实际像素，每个像素有三个数字描述分别代表红，绿，蓝</p><p>使用<code>convert</code> 命令转换.ppm格式到其他标准格式。</p><blockquote><p>The command <code>convert -compress none glider.png glider.ppm </code>can convert a png to a PPM P3 format, albeit with a different spacing convention than the one we will be using in this project. Similarly, the command <code>convert glider.ppm glider.png </code>can be used to convert a ppm back to a png. This can be useful for debugging purposes, and seeing the actual image files</p></blockquote><h3 id="File-I-O"><a href="#File-I-O" class="headerlink" title="File I&#x2F;O"></a>File I&#x2F;O</h3><p>以<code>Color</code>存储pixel 的颜色，<code>Image</code>形式存储所有图片</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Color</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">uint8_t</span> R;<br><span class="hljs-type">uint8_t</span> G;<br><span class="hljs-type">uint8_t</span> B;<br>&#125; Color;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Image</span></span><br><span class="hljs-class">&#123;</span><br>Color **image;<br><span class="hljs-type">uint32_t</span> rows;<br><span class="hljs-type">uint32_t</span> cols;<br>&#125; Image;<br></code></pre></td></tr></table></figure><p>使用file I&#x2F;O 管理文件 <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">fopen</a> <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">fclose</a>  <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fscanf.htm">fscanf</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fopen opens a file pointer to the &quot;diary.txt&quot; file.</span><br><span class="hljs-comment">// The &quot;r&quot; indicates that the file should be opened in &quot;read mode&quot;.</span><br><span class="hljs-comment">// Other modes are detailed in the documentation linked above.</span><br>FILE *fp = fopen(<span class="hljs-string">&quot;diary.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><br><span class="hljs-comment">// fscanf reads the first word and first number from the given file pointer into buf and num, respectively.</span><br><span class="hljs-comment">// The second argument is a string format, specifying what exactly fscanf should be reading from the file pointer.</span><br><span class="hljs-comment">// More options can for the string format can be found in the documentation linked above,</span><br><span class="hljs-comment">// but you may need to Google to figure out how to scan in specific types.</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> num;<br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%s %d&quot;</span>, buf, &amp;num);<br><br><span class="hljs-comment">// fclose simply closes the file pointer after we&#x27;re done with it.</span><br><span class="hljs-comment">// This frees the memory that fopen allocated for the file.</span><br><span class="hljs-comment">// This is also a necessary step whenever we are writing to a file:</span><br><span class="hljs-comment">// without closing the pointer, you may lose the last few lines</span><br><span class="hljs-comment">// you want to write.</span><br>fclose(fp);<br></code></pre></td></tr></table></figure><h2 id="Part-A1"><a href="#Part-A1" class="headerlink" title="Part A1"></a>Part A1</h2><p>实现见 <a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/imageloader.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/imageloader.c</a></p><h3 id="readData"><a href="#readData" class="headerlink" title="readData()"></a><strong>readData()</strong></h3><p>主要关注下分配空间，理清楚malloc()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Image *img = (Image*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Image));<br></code></pre></td></tr></table></figure><p>这里分配了一个 <code>Image</code>结构体的空间，用于存储图像的信息，包括图像的行数，列数，以及指向像素空间的指针<br>分配<code>sizeof(struct Image)</code>大小的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">img-&gt;image = (Color **)<span class="hljs-built_in">malloc</span>(totpixel*<span class="hljs-keyword">sizeof</span>(Color*));<br></code></pre></td></tr></table></figure><p>这里分配了一个指针数组，用于存储<code>Color</code>结构体的指针。</p><blockquote><p><code>img-&gt;image</code>为<code>Color **</code> 即 <code>img</code>是一个指向指针数组的指针，其中的每个指针指向一个<code>Color</code>对象</p></blockquote><p><code>Img</code>是一个<code>Color**</code> 类型，指向的对象是包含 <code>totpixel</code> 个 Color* 的指针数组<br>分配<code>totpixel*sizeof(Color *)</code> 大小的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;totpixel;i++)&#123;<br>    *(img-&gt;image+i) = (Color*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Color));`<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在上一步分配的指针数组中的每一个指针指向的位置，分配了一个<code>Color</code> 结构体的内存</p><p><code>*(img-&gt;image + i)</code> 是一个 <code>Color*</code> 类型，所以我们分配了 <code>sizeof(Color)</code> 字节的内存空间，来存储每个像素的颜色数据。</p><p>其次<code>fscanf</code>的参数我是根据<code>make imageloader</code>的报错结果修改的，我最开始是认为是<code>3u</code>的就是3位数的unit32，不理解<code>hhu</code>是什么原因。</p><div class="note note-info">            <p>注：hhu时unit8的读取</p>          </div><h3 id="WriteData-Free"><a href="#WriteData-Free" class="headerlink" title="WriteData() &amp; Free()"></a>WriteData() &amp; Free()</h3><p>逻辑上很简单，Free()的话，记得倒着释放，不然会找不到之后的地址。</p><h2 id="Part-A2"><a href="#Part-A2" class="headerlink" title="Part A2"></a>Part A2</h2><p>完成<code>Steganography</code>，完整见<a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/steganography.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/steganography.c</a></p><p>基于<a href="https://zh.wikipedia.org/wiki/%E9%9A%90%E5%86%99%E6%9C%AF">隐写术</a></p><blockquote><p>载体文件（cover file）相对隐秘文件的大小（指数据含量，以比特计）越大，隐藏后者就越加容易。</p><p>因为这个原因，数字图像（包含有大量的数据）在互联网和其他传媒上被广泛用于隐藏消息。这种方法使用的广泛程度无从查考。例如：一个24位的位图中的每个像素的三个颜色分量（红，绿和蓝）各使用8个比特来表示。如果我们只考虑蓝色的话，就是说有28种不同的数值来表示深浅不同的蓝色。而像11111111和11111110这两个值所表示的蓝色，人眼几乎无法区分。因此，这个最低有效位就可以用来存储颜色之外的信息，而且在某种程度上几乎是检测不到的。如果对红色和绿色进行同样的操作，就可以在差不多三个像素中存储一个字节的信息。</p><p>更正式一点地说，使隐写的信息难以探测的，也就是保证“有效载荷”（需要被隐蔽的信号）对“载体”（即原始的信号）的调制对载体的影响看起来（理想状况下甚至在统计上）可以忽略。这就是说，这种改变应该无法与载体中的噪声加以区别。</p><p>隐写术也可以用作电子水印，这里一条消息（往往只是一个标识符）被隐藏到一幅图像中，使得其来源能够被跟踪或校验。但往往隐写术不具有良好的强健性，当图像被稍微修改后，隐入的消息就无法提取校验了。</p></blockquote><h3 id="evaluateOnePixel"><a href="#evaluateOnePixel" class="headerlink" title="evaluateOnePixel"></a>evaluateOnePixel</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 根据给定的图片和行列确定该位置像素的颜色，要求不影响原图片，给新的颜色分配空间</span><br>Color *<span class="hljs-title function_">evaluateOnePixel</span><span class="hljs-params">(Image *image, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col)</span><br></code></pre></td></tr></table></figure><p>返回值是一个<code>Color *</code>，设置为<code>secret</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Color * secret = (Color *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Color));<br></code></pre></td></tr></table></figure><p>根据原理，确定该位置的颜色</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> LSB = (*p)-&gt;B &amp; <span class="hljs-number">1</span>;<br>secret-&gt;B = secret-&gt;G = secret-&gt;R = LSB*<span class="hljs-number">255</span>;<br></code></pre></td></tr></table></figure><h3 id="steganography"><a href="#steganography" class="headerlink" title="steganography"></a>steganography</h3><p>对每个像素分别调用<code>evaluateOnePixel</code>即可</p><div class="note note-info">            <p>完成part A2 时最好自己写测试，而不是使用make steganography命令，至少在我这里，这个命令会导致之前编译成功的<code>makeloader.c</code>的<code>fscanf</code>的参数出现问题。</p><p>另编译时，应该同时编译<code>steganography.c</code>和<code>makeloader.c</code>，因为<code>#include &quot;makeloader.h&quot;</code> 即</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -o steganography steganography.c makeloader.c<br></code></pre></td></tr></table></figure>          </div><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>完成 <strong>The Game of Life</strong> 完整代码见<a href="https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/gameoflife.c">https://github.com/2333monster/my-cs61c-proj/blob/master/proj1/gameoflife.c</a></p><blockquote><p>规则：</p><ol><li>任何一个周围（8个邻居中）有2或3个活细胞的活细胞，在下一代存活</li><li>任何一个周围有3个或者细胞邻居的死细胞，在下一代存活</li><li>所有其他类型的活细胞下一代带死亡，死细胞下一代仍死亡</li></ol></blockquote><p>规则编码</p><table>  <tbody>    <tr>      <th>If my state is...</th>      <th colspan="9"> alive (1)</th>      <th colspan="9"> dead (0)</th>    </tr>    <tr>      <th>And the number of alive neighbors is...</th>      <td>8</td>      <td>7</td>      <td>6</td>      <td>5</td>      <td>4</td>      <td>3</td>      <td>2</td>      <td>1</td>      <td>0</td>      <td>8</td>      <td>7</td>      <td>6</td>      <td>5</td>      <td>4</td>      <td>3</td>      <td>2</td>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>Then the next state I will be...</th>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>0</td>      <td>1</td>      <td>0</td>      <td>0</td>      <td>0</td>    </tr>    <tr>      <th>Converting the 18 bits above to a hexadecimal number</th>      <td colspan="18"><p align="center">0b00 0001 1000 0000 1000</p>        <p align="center">0x1808</p></td>      </tr>  </tbody></table>这也被称为0x1808 rule, 还有其他的[interesting rule](https://en.wikipedia.org/wiki/Life-like_cellular_automaton#A_selection_of_Life-like_rules) ，修改hexadecimal number 的值即可(0x0 - 0x3FFFF) <h3 id="evaluateOneCell"><a href="#evaluateOneCell" class="headerlink" title="evaluateOneCell()"></a>evaluateOneCell()</h3><div class="note note-info">            <p>注意：测试的代码中颜色值只有255或0，255表示alive，0表示dead</p><p>三通道颜色（红，绿，蓝）要分别判断，即分别R,G,B是否存活，依据周围8个细胞的R,G,B状态 </p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> rx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> cx[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><br>···<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)&#123;<br>    <span class="hljs-type">int</span> new_row = ring(row+rx[i],image-&gt;rows);<br>    <span class="hljs-type">int</span> new_col = ring(col+cx[i],image-&gt;cols);<br></code></pre></td></tr></table></figure><p>周围8个细胞的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> idR = <span class="hljs-number">9</span>*isaliveR + aliveNeighbourR;<br><span class="hljs-keyword">if</span>(rule &amp; (<span class="hljs-number">1</span>&lt;&lt;idR))&#123;<br>    nextState-&gt;R = <span class="hljs-number">255</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    nextState-&gt;R = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据规则判断细胞是否存活</p><p>这样设计的原理如下</p><p><code>int idR = 9*isaliveR + aliveNeighbourR</code> :</p><p>首先<code>isaliveR</code>有两种状态0 和 1，<code>9 * isaliveR</code> 是决定状态的位置，注意上面的规则编码表格，每个细胞周围的细胞存活数有9种情况（0~8），使用<code>9 * isaliveR</code> 当<code>isaliveR = 0 </code>时，就处在<code>dead()</code>的范围</p><p>，加上<code>aliveNeighbourR</code>即可确定该细胞的状况，比如死亡周围有5个存活细胞。同理<code>isaliveR = 1</code>。</p><p><code>rule &amp; (1 &lt;&lt; idR)</code></p><p>1左移<code>idR</code>位，<code>idR = 4</code> 则 <code>1 &lt;&lt; 4</code>即 <code>0000 0000 0000 1000</code>，再跟<code>rule</code>取和，<code>0000 0000 0000 1000</code> 与 <code>0001 1000 0000 1000</code> 取和，得<code>0000 0000 0000 1000</code>。显然若结果不为零，则细胞下一代存活</p><h3 id="life-main"><a href="#life-main" class="headerlink" title="life() &amp; main()"></a>life() &amp; main()</h3><p>类似于<code>steganography()</code>的结构</p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs61c-lab01</title>
    <link href="/2023/08/04/cs61c-lab01/"/>
    <url>/2023/08/04/cs61c-lab01/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab1-Number-Rep-C-and-CGDB"><a href="#Lab1-Number-Rep-C-and-CGDB" class="headerlink" title="Lab1: Number Rep, C and CGDB"></a>Lab1: Number Rep, C and CGDB</h1><blockquote><p>cs61c - Great Ideas in Computer Architecture (Machine Structures) lab 笔记第一篇</p><p>课程主页：<a href="https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week">https://inst.eecs.berkeley.edu/~cs61c/fa20/#by-week</a></p><p>个人仓库：<a href="https://github.com/2333monster/my-cs61c-lab">https://github.com/2333monster/my-cs61c-lab</a></p><p>参考</p><p>gdb调试手册：<a href="https://blog.nowcoder.net/n/1957d46e0ee34168aee2289faf36ee5c#gdb_20">https://blog.nowcoder.net/n/1957d46e0ee34168aee2289faf36ee5c#gdb_20</a></p><p>gdb调试指南：<a href="https://www.yanbinghu.com/2019/04/20/41283.html">https://www.yanbinghu.com/2019/04/20/41283.html</a></p></blockquote><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><p>获得skeleton code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ git remote add starter https://github.com/61c-teach/fa20-lab-starter.git<br>$ git pull starter master<br></code></pre></td></tr></table></figure><h2 id="Compiling-and-Running-a-C-Program"><a href="#Compiling-and-Running-a-C-Program" class="headerlink" title="Compiling and Running a C Program"></a>Compiling and Running a C Program</h2><p>使用gcc 编译c程序，生成执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ gcc hello.c<br></code></pre></td></tr></table></figure><p>使用执行文件<code>a.out</code>的名称运行c程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ ./a.out<br></code></pre></td></tr></table></figure><p>或者使用<code>-o</code>命令，它能指定执行文件的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">$ gcc -o hello hello.c<br>$ ./hello<br></code></pre></td></tr></table></figure><h2 id="Exercise-1-See-what-you-can-C"><a href="#Exercise-1-See-what-you-can-C" class="headerlink" title="Exercise 1: See what you can C"></a>Exercise 1: See what you can C</h2><p>本练习中，将看到宏定义处理器的示例</p><p>更改V0 ~ V3 的宏定义，使其输出以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Plaintext">Berkeley eccentrics:<br>====================<br>Happy Happy Happy<br>Yoshua<br>Go BEARS!<br></code></pre></td></tr></table></figure><p>更改后（好像不要求完全不同，完全不同确实写不出来）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> V0 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V1 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V2 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V3 1</span><br></code></pre></td></tr></table></figure><h2 id="Exercise-2-Catch-those-bugs"><a href="#Exercise-2-Catch-those-bugs" class="headerlink" title="Exercise 2: Catch those bugs!"></a>Exercise 2: Catch those bugs!</h2><p>使用GDB进行Debug，<a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/gdb5-refcard.pdf">GDB reference card</a></p><blockquote><p>GDB stands for “GNU De-Bugger.”</p></blockquote><p>使用<code>-g</code>调用 (c)gdb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -g -o hello hello.c</span><br></code></pre></td></tr></table></figure><p>这会生成一个可被<code>gdb</code>识别的可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gdb hello</span><br></code></pre></td></tr></table></figure><p><strong>gdb常用调试指令</strong></p><table><thead><tr><th>调试指令</th><th>作用</th></tr></thead><tbody><tr><td>b（break） 行号</td><td>在源代码指定的某一行设置断点，其中行号用于指定具体打断点的位置。</td></tr><tr><td>r（run）</td><td>执行被调试的程序，其会自动在第一个断点处暂停执行。</td></tr><tr><td>n（next）(int)</td><td>令程序一行代码一行代码的执行。执行n次</td></tr><tr><td>p（print） 变量名</td><td>打印指定变量的值</td></tr><tr><td>l（list）</td><td>显示源程序代码的内容，包括各行代码所在的行号。</td></tr><tr><td>q（quit）</td><td>终止调试。</td></tr></tbody></table><p>断点设置格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break location    //b 位置<br>(gdb) break ... if cond //b 表达式<br></code></pre></td></tr></table></figure><ul><li>location</li></ul><table><thead><tr><th>location 的值</th><th>含 义</th></tr></thead><tbody><tr><td>linenum</td><td>linenum 是一个整数，表示要打断点处代码的行号。</td></tr><tr><td>filename:linenum</td><td>filename 表示源程序文件名；linenum 为整数，表示具体行数。整体的意思是在指令文件 filename 中的第 linenum 行打断点。</td></tr><tr><td>+ offset</td><td>offset 为整数，+offset 表示以当前程序暂停位置为准，<strong>向后数</strong> offset 行处打断点</td></tr><tr><td>- offset</td><td>offset 为整数，-offset 表示以当前程序暂停位置为准，<strong>向前数</strong> offset 行处打断点</td></tr><tr><td>function</td><td>function 表示程序中包含的函数的函数名，即 break 命令会在该函数内部的开头位置打断点，程序会执行到该函数第一行代码处暂停。</td></tr><tr><td>filename:function</td><td>filename 表示远程文件名；function 表示程序中函数的函数名。整体的意思是在指定文件 filename 中 function 函数的开头位置打断点。</td></tr></tbody></table><ul><li>cond 表达式</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b 7 if num&gt;10  //如果num&gt;10 在第 7 行打断点<br></code></pre></td></tr></table></figure><h3 id="Action-Item"><a href="#Action-Item" class="headerlink" title="Action Item"></a>Action Item</h3><ol><li>setting a breakpoint at main</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) b hello.c: main<br></code></pre></td></tr></table></figure><ol start="2"><li>using gdb’s run command</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run<br></code></pre></td></tr></table></figure><ol start="3"><li>using gdb’s single-step command</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n<br></code></pre></td></tr></table></figure><h4 id="gdb-questions"><a href="#gdb-questions" class="headerlink" title="gdb questions"></a>gdb questions</h4><ol><li><p>While you’re in a gdb session, how do you <strong>set the arguments</strong> that will be passed to the program when it’s run?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set args 5<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>create a breakpoint</strong>?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">b filename: linenum<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>execute the next line of C code</strong> in the program after stopping at a breakpoint?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n(next) / s(step)<br></code></pre></td></tr></table></figure></li><li><p>If the next line of code is a function call, you’ll execute the whole function call at once if you use your answer to #3. (If not, consider a different command for #3!) How do you tell GDB that you <strong>want to debug the code inside the function</strong> (i.e. step into the function) instead? (If you changed your answer to #3, then that answer is most likely now applicable here.)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">step<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>continue the program after stopping</strong> at a breakpoint?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run<br></code></pre></td></tr></table></figure></li><li><p>How can you <strong>print the value of a variable</strong> (or even an expression like 1+2) in gdb?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">p 1+2<br>p variable_name<br></code></pre></td></tr></table></figure></li><li><p>How do you configure gdb so it <strong>displays the value of a variable after every step</strong>?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">display variable<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>show a list of all variables and their values</strong> in the current function?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">info args<br></code></pre></td></tr></table></figure></li><li><p>How do you <strong>quit</strong> out of gdb?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">q<br></code></pre></td></tr></table></figure></li></ol><h2 id="Exercise-3-Debugging-w-YOU-ser-input"><a href="#Exercise-3-Debugging-w-YOU-ser-input" class="headerlink" title="Exercise 3: Debugging w&#x2F; YOU(ser input)"></a>Exercise 3: Debugging w&#x2F; YOU(ser input)</h2><p>好像是关于redirection ，没懂</p><h2 id="Exercise-4-Valgrind’ing-away"><a href="#Exercise-4-Valgrind’ing-away" class="headerlink" title="Exercise 4: Valgrind’ing away"></a>Exercise 4: Valgrind’ing away</h2><p>有两种bug类型</p><ol><li>bohrbugs：在一致的稳定的情况下会重复出现的错误</li><li>heisenbugs：在相同情况下不一定会重复出现，一般由于内存管理不当</li></ol><p>使用Valgrind 找出”heisenbugs” </p><blockquote><p>To help catch these “heisenbugs” we will use a tool called Valgrind. Valgrind is a program which emulates your CPU and tracks your memory accesses. This slows down the process you’re running (which is why we don’t, for example, always run all executables inside Valgrind) but also can expose bugs that may only display visible incorrect behavior under a unique set of circumstances.</p></blockquote><p>安装valgrind （在ubuntu环境下）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt install valgrind</span><br></code></pre></td></tr></table></figure><p><code>segfault_ex</code> 出现错误的原因</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;<br>        a[i] = i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问数组外未定义的内存，典型的heisenbug。</p><p><strong>使用valgrind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o segfault_ex.exe segfault_ex.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">valgrind ./segfault_ex.exe</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">==15931== Invalid write of size 4<br>==15931==   at 0x10914F: main (in /home/moxilai/cs61c-lab/lab01/segfault.exe)<br>==15931== Address 0x1fff001000 is not stack&#x27;d, malloc&#x27;d or (recently) free&#x27;d<br></code></pre></td></tr></table></figure><p><code>no_segfalut</code> 的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">unsigned</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(a); j++) &#123;<br>        total += a[j];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum of array is %d\n&quot;</span>, total);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for (int j = 0; j &lt; sizeof(a); j++)</code> 使用sizeof(a) a 是一个包含五个元素的整型数组，sizeof的结果是5*4&#x3D;20，而不是5，导致访问未定义的内存，从而产生未知的结果。这是一个典型的Heisenbug问题，因为其结果取决于内存中未定义的值，可能会导致程序崩溃或输出错误的结果。</p><p><strong>使用valgrind</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o no_segfault.exe no_segfault_ex.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">valgrind ./no_segfault.exe</span><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D9B56: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Use of uninitialised value of size 8<br>==16089==    at 0x48BD33B: _itoa_word (_itoa.c:177)<br>==16089==    by 0x48D8B3D: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48BD34C: _itoa_word (_itoa.c:177)<br>==16089==    by 0x48D8B3D: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D9643: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br>==16089==<br>==16089== Conditional jump or move depends on uninitialised value(s)<br>==16089==    at 0x48D8C85: __vfprintf_internal (vfprintf-internal.c:1516)<br>==16089==    by 0x48C381E: printf (printf.c:33)<br>==16089==    by 0x1091E7: main (in /home/moxilai/cs61c-lab/lab01/no_segfault.exe)<br></code></pre></td></tr></table></figure><p>关键词：uninitialised value </p><p>分析上面两个程序</p><ol><li><p>Why <strong>didn’t</strong> the <code>no_segfault_ex</code> program segfault?<br>首先c以这种形式分配数组内存是stack中给了一个指针，随着j的增大，会访问a[5]~a[19]这实际是a+5 ~ a+19 的内存，这些内存是存在的，由于这不是分配给a 的内存，且没有初始化，其中会存储着脏数据，导致不可确定的。不过由于没有超出stack的容量，不会造成segfault（程序崩溃）</p></li><li><p>Why does the <code>no_segfault_ex</code> produce inconsistent outputs?<br>同上，不确定的数据导致不确定的输出</p></li><li><p>Why is <code>sizeof</code> incorrect? How could you still use <code>sizeof</code> but make the code correct?<br>同上，更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br>arraylength = <span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arraylength;j++)<br>    ...<br></code></pre></td></tr></table></figure></li></ol><h2 id="Exercise-5-Pointers-and-Structures-in-C"><a href="#Exercise-5-Pointers-and-Structures-in-C" class="headerlink" title="Exercise 5: Pointers and Structures in C"></a>Exercise 5: Pointers and Structures in C</h2><p>在ll_cycle.c中，完成函数ll_has_cycle()来实现以下检查单向链表是否有环的算法。</p><blockquote><ol><li>Start with two pointers at the head of the list. We’ll call the first one tortoise and the second one hare.</li><li>Advance hare by two nodes. If this is not possible because of a null pointer, we have found the end of the list, and therefore the list is acyclic.</li><li>Advance tortoise by one node.</li><li>If tortoise and hare point to the same node, the list is cyclic. Otherwise, go back to step 2.</li></ol></blockquote><p><code>ll_cycle.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ll_cycle.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">ll_has_cycle</span><span class="hljs-params">(node *head)</span> &#123;<br>    <span class="hljs-comment">/* your code here */</span><br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    node *tortoise = head;<br>    node *hare = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(tortoise != <span class="hljs-literal">NULL</span> &amp;&amp; hare != <span class="hljs-literal">NULL</span> &amp;&amp; hare-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(tortoise == hare)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        tortoise = tortoise-&gt;next;<br>        hare = hare-&gt;next-&gt;next;<br>    &#125;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释算法原理<a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd.27s_Tortoise_and_Hare">Wikipedia article</a></p>]]></content>
    
    
    <categories>
      
      <category>Architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs61c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参考.md</title>
    <link href="/2023/07/27/%E5%8F%82%E8%80%83/"/>
    <url>/2023/07/27/%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>hexo+github 部署个人网页 <a href="https://zhuanlan.zhihu.com/p/547520780">https://zhuanlan.zhihu.com/p/547520780</a></p><p>shell chmod 命令 <a href="https://www.runoob.com/linux/linux-comm-chmod.html">https://www.runoob.com/linux/linux-comm-chmod.html</a></p><p>hexo 插入本地图片 解决了我的问题 <a href="https://www.jianshu.com/p/81191bc2cb2d">https://www.jianshu.com/p/81191bc2cb2d</a> 另一种方法: <a href="https://blog.csdn.net/m0_43401436/article/details/107191688">https://blog.csdn.net/m0_43401436/article/details/107191688</a></p><p>risc-v caller-callee <a href="https://zhuanlan.zhihu.com/p/295439950">https://zhuanlan.zhihu.com/p/295439950</a></p><p>risc-v green card <a href="https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard.pdf">https://inst.eecs.berkeley.edu/~cs61c/sp21/resources-pdfs/riscvcard.pdf</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
